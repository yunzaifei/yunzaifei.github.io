<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云在飞的博客</title>
  
  <subtitle>如果你惟一的工具是一把锤子，你往往会把一切问题看成钉子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yunzaifei.github.io/"/>
  <updated>2024-01-03T08:10:22.380Z</updated>
  <id>http://yunzaifei.github.io/</id>
  
  <author>
    <name>yunzaifei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="http://yunzaifei.github.io/2024/01/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yunzaifei.github.io/2024/01/03/Docker常用命令/</id>
    <published>2024-01-03T08:09:59.000Z</published>
    <updated>2024-01-03T08:10:22.380Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>服务</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Docker版本信息</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><ul><li><strong>镜像</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出镜像</span></span><br><span class="line">docker images 或者 docker image <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 删除指定镜像</span></span><br><span class="line">docker rmi &lt;镜像Id&gt; 或者 docker image <span class="built_in">rm</span> &lt;镜像Id&gt;</span><br><span class="line"><span class="comment"># 删除所有镜像</span></span><br><span class="line">docker rmi $(docker images -q)</span><br><span class="line"><span class="comment"># 删除所有&lt;none&gt;镜像</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">&quot;none&quot;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line"><span class="comment"># 导入镜像</span></span><br><span class="line">docker load</span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">docker build docker build -t [镜像自定义名称] .</span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run [镜像ID] docker run -it --name [容器自定义名称] -d [镜像名称]:latest</span><br><span class="line"><span class="comment"># 保存镜像到本地</span></span><br><span class="line">docker save [镜像名称] | gzip &gt; [保存文件名称]</span><br><span class="line"><span class="comment"># 加载本地镜像</span></span><br><span class="line">docker load &lt; [保存镜像文件名称]</span><br></pre></td></tr></table></figure><ul><li><strong>容器</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 列出本机所有的容器（包括停止和运行）</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 新建并启动</span></span><br><span class="line">docker run [镜像名/镜像ID]</span><br><span class="line"><span class="comment"># 启动已终止容器</span></span><br><span class="line">docker start [容器ID]</span><br><span class="line"><span class="comment"># 停止运行的容器</span></span><br><span class="line">docker stop [容器ID]</span><br><span class="line"><span class="comment"># 杀死容器进程</span></span><br><span class="line">docker <span class="built_in">kill</span> [容器ID]</span><br><span class="line"><span class="comment"># 重启容器</span></span><br><span class="line">docker restart [容器ID]</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> [容器ID]</span><br><span class="line"><span class="comment"># 交互式进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> [容器ID]</span><br><span class="line"><span class="comment"># 导出容器</span></span><br><span class="line">docker <span class="built_in">export</span> [容器ID]</span><br><span class="line"><span class="comment"># 导入容器</span></span><br><span class="line">docker import [路径]</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">docker logs [容器ID]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="Docker" scheme="http://yunzaifei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yunzaifei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>服务器设置和Docker安装</title>
    <link href="http://yunzaifei.github.io/2024/01/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E5%92%8CDocker%E5%AE%89%E8%A3%85/"/>
    <id>http://yunzaifei.github.io/2024/01/03/服务器设置和Docker安装/</id>
    <published>2024-01-03T08:06:37.000Z</published>
    <updated>2024-01-03T08:08:02.926Z</updated>
    
    <content type="html"><![CDATA[<p>服务器厂商每年都会搞促销活动，但是促销只针对新买的服务器，而之前买的服务器续费就没有促销。这样就导致，旧的服务器到期了就不能用了，上面部署的服务都要迁移到新的服务器。</p><h3 id="服务器设置"><a href="#服务器设置" class="headerlink" title="服务器设置"></a>服务器设置</h3><p>服务器选<code>Debian</code></p><ol><li>更改<code>root</code>密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><ol start="2"><li>新建用户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m zyf</span><br></pre></td></tr></table></figure><ol start="3"><li>配置免密登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地生成公钥、私钥</span></span><br><span class="line">ssh-keygen -t ed25519 -f xxx_ed25519</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目标服务器操作, 复制生成的公钥</span></span><br><span class="line">vi /home/zyf/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="built_in">chown</span> -R zyf:zyf /home/zyf/.ssh</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 700 /home/zyf/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 /home/zyf/.ssh/authorized_keys</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>禁用密码登录和<code>root</code>登录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 禁止root登录 PermitRootLogin yes改成no</span></span><br><span class="line"><span class="comment"># 禁止密码登录 PasswordAuthentication yes改为no</span></span><br><span class="line"><span class="comment"># 启用密钥验证 RSAAuthentication yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启sshd服务</span></span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><ol><li>注册源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add Docker&#x27;s official GPG key:</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg</span><br><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the repository to Apt sources:</span></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ol start="2"><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;服务器厂商每年都会搞促销活动，但是促销只针对新买的服务器，而之前买的服务器续费就没有促销。这样就导致，旧的服务器到期了就不能用了，上面部署的服务都要迁移到新的服务器。&lt;/p&gt;
&lt;h3 id=&quot;服务器设置&quot;&gt;&lt;a href=&quot;#服务器设置&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Docker" scheme="http://yunzaifei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yunzaifei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>gitea的docker安装</title>
    <link href="http://yunzaifei.github.io/2023/06/02/gitea%E7%9A%84docker%E5%AE%89%E8%A3%85/"/>
    <id>http://yunzaifei.github.io/2023/06/02/gitea的docker安装/</id>
    <published>2023-06-02T06:35:54.000Z</published>
    <updated>2024-01-03T08:11:43.049Z</updated>
    
    <content type="html"><![CDATA[<p><code>Gitea</code>是一个自己托管的 Git 服务程序。他和<code>GitHub</code>, <code>Bitbucket</code>或<code>Gitlab</code>等比较类似。他是从<a href="http://gogs.io/">Gogs</a> 发展而来，<code>Gitea</code>的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。</p><ul><li>官网：<a href="https://gitea.io/zh-cn/">https://gitea.io/zh-cn/</a></li></ul><h3 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h3><p><code>Gitea</code>在其<code>Docker Hub</code>组织内提供自动更新的<code>Docker</code>镜像。可以始终使用最新的稳定标签或使用其他服务来更新<code>Docker</code>镜像。</p><ol><li>更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> update</span><br><span class="line">sudo apt-<span class="built_in">get</span> install ca-certificates curl gnupg</span><br></pre></td></tr></table></figure><ol start="2"><li>添加<code>Docker</code>的官方<code>GPG</code>密钥：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install -m <span class="number">0755</span> -d <span class="regexp">/etc/</span>apt/keyrings</span><br><span class="line">curl -fsSL https:<span class="regexp">//</span>download.docker.com<span class="regexp">/linux/</span>debian<span class="regexp">/gpg | sudo gpg --dearmor -o /</span>etc<span class="regexp">/apt/</span>keyrings/docker.gpg</span><br><span class="line">sudo chmod a+r <span class="regexp">/etc/</span>apt<span class="regexp">/keyrings/</span>docker.gpg</span><br></pre></td></tr></table></figure><ol start="3"><li>使用以下命令设置软件源：</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo \</span><br><span class="line">  <span class="string">&quot;deb [arch=&quot;</span>$(dpkg --<span class="keyword">print</span>-architecture)<span class="string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  &quot;</span>$(. <span class="regexp">/etc/</span>os-release &amp;&amp; echo <span class="string">&quot;$VERSION_CODENAME&quot;</span>)<span class="string">&quot; stable&quot;</span> | \</span><br><span class="line">  sudo tee <span class="regexp">/etc/</span>apt<span class="regexp">/sources.list.d/</span>docker.list &gt; <span class="regexp">/dev/</span><span class="keyword">null</span></span><br></pre></td></tr></table></figure><ol start="4"><li>更新 apt 包索引：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><ol start="5"><li>安装<code>Docker Engine</code>、<code>containerd</code>和<code>Docker Compose</code>:</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-<span class="keyword">cli</span> containerd.io docker-buildx-<span class="keyword">plugin</span> docker-compose-<span class="keyword">plugin</span></span><br></pre></td></tr></table></figure><h3 id="基本安装"><a href="#基本安装" class="headerlink" title="基本安装"></a>基本安装</h3><p>最简单的设置只是创建一个卷和一个网络，然后将<code>gitea/gitea:latest</code>镜像作为服务启动。创建一个类似<code>gitea</code>的目录，并将以下内容粘贴到名为<code>docker-compose.yml</code>的文件中。请注意，该卷应由配置文件中指定的<code>UID/GID</code>的用户&#x2F;组拥有。如果您不授予卷正确的权限，则容器可能无法启动。另请注意，标签 :latest 将安装当前的开发版本。对于稳定的发行版，您可以使用 :1 或指定某个发行版，例如 1.19.0-rc1。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">version</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">gitea</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">external</span><span class="punctuation">:</span> <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">services</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">server</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">image</span><span class="punctuation">:</span> <span class="string">gitea/gitea:1.19.0-rc1</span></span><br><span class="line">    <span class="attribute">container_name</span><span class="punctuation">:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">environment</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1000</span></span><br><span class="line">    <span class="attribute">restart</span><span class="punctuation">:</span> <span class="string">always</span></span><br><span class="line">    <span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">volumes</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attribute">ports</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;222:22&quot;</span></span><br></pre></td></tr></table></figure><h3 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h3><p>要将<code>Gitea</code>与<code>MySQL</code>数据库结合使用，请将这些更改应用于上面创建的<code>docker-compose.yml</code>文件。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">version</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">gitea</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">external</span><span class="punctuation">:</span> <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">services</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">server</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">image</span><span class="punctuation">:</span> <span class="string">gitea/gitea:1.19.0-rc1</span></span><br><span class="line">    <span class="attribute">container_name</span><span class="punctuation">:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">environment</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1000</span></span><br><span class="line">+      - GITEA__database__DB_TYPE=mysql</span><br><span class="line">+      - GITEA__database__HOST=db:3306</span><br><span class="line"><span class="attribute">+      - GITEA__database__NAME=gitea</span></span><br><span class="line"><span class="attribute">+      - GITEA__database__USER=gitea</span></span><br><span class="line"><span class="attribute">+      - GITEA__database__PASSWD=gitea</span></span><br><span class="line"><span class="attribute">    restart</span><span class="punctuation">:</span> <span class="string">always</span></span><br><span class="line">    <span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">volumes</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attribute">ports</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;222:22&quot;</span></span><br><span class="line"><span class="attribute">+    depends_on</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+      - db</span></span><br><span class="line"><span class="attribute">+</span></span><br><span class="line"><span class="attribute">+  db</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+    image</span><span class="punctuation">:</span> <span class="string">mysql:8</span></span><br><span class="line"><span class="attribute">+    restart</span><span class="punctuation">:</span> <span class="string">always</span></span><br><span class="line"><span class="attribute">+    environment</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+      - MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class="line"><span class="attribute">+      - MYSQL_USER=gitea</span></span><br><span class="line"><span class="attribute">+      - MYSQL_PASSWORD=gitea</span></span><br><span class="line"><span class="attribute">+      - MYSQL_DATABASE=gitea</span></span><br><span class="line"><span class="attribute">+    networks</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+      - gitea</span></span><br><span class="line"><span class="attribute">+    volumes</span><span class="punctuation">:</span></span><br><span class="line">+      - ./mysql:/var/lib/mysql</span><br></pre></td></tr></table></figure><h3 id="命名卷"><a href="#命名卷" class="headerlink" title="命名卷"></a>命名卷</h3><p>要使用命名卷而不是主机卷，请在<code>docker-compose.yml</code>配置中定义并使用命名卷。此更改将自动创建所需的卷。您无需担心命名卷的权限；<code>Docker</code>将自动处理该问题。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">version</span><span class="punctuation">:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">gitea</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">external</span><span class="punctuation">:</span> <span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">+volumes</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+  gitea</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">+    driver</span><span class="punctuation">:</span> <span class="string">local</span></span><br><span class="line"><span class="attribute">+</span></span><br><span class="line"><span class="attribute">services</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">server</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">image</span><span class="punctuation">:</span> <span class="string">gitea/gitea:1.19.0-rc1</span></span><br><span class="line">    <span class="attribute">container_name</span><span class="punctuation">:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">restart</span><span class="punctuation">:</span> <span class="string">always</span></span><br><span class="line">    <span class="attribute">networks</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attribute">volumes</span><span class="punctuation">:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">     - ./gitea:/data</span></span><br><span class="line">+      - gitea:/data</span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attribute">ports</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;222:22&quot;</span></span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>要基于<code>docker-compose</code>启动此设置，请执行<code>docker-compose up -d</code>，以在后台启动<code>Gitea</code>。使用<code>docker-compose ps</code>将显示 Gitea 是否正确启动。可以使用<code>docker-compose logs</code>查看日志。</p><p>要关闭设置，请执行<code>docker-compose down</code>。这将停止并杀死容器。这些卷将仍然存在。</p><p>注意：如果在 http 上使用非 3000 端口，请更改<code>app.ini</code>以匹配<code>LOCAL_ROOT_URL = http://localhost:3000/</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Gitea&lt;/code&gt;是一个自己托管的 Git 服务程序。他和&lt;code&gt;GitHub&lt;/code&gt;, &lt;code&gt;Bitbucket&lt;/code&gt;或&lt;code&gt;Gitlab&lt;/code&gt;等比较类似。他是从&lt;a href=&quot;http://gogs.io/&quot;&gt;G
      
    
    </summary>
    
      <category term="Git" scheme="http://yunzaifei.github.io/categories/Git/"/>
    
    
      <category term="Docker" scheme="http://yunzaifei.github.io/tags/Docker/"/>
    
      <category term="Git" scheme="http://yunzaifei.github.io/tags/Git/"/>
    
      <category term="gitea" scheme="http://yunzaifei.github.io/tags/gitea/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs项目配置Typescript,Eslint,prettier等</title>
    <link href="http://yunzaifei.github.io/2022/12/27/Nodejs%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AETypescript-Eslint-prettier%E7%AD%89/"/>
    <id>http://yunzaifei.github.io/2022/12/27/Nodejs项目配置Typescript-Eslint-prettier等/</id>
    <published>2022-12-27T06:21:02.000Z</published>
    <updated>2022-12-27T07:39:41.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现代化的工程项目搭建，已经不仅仅满足于可以用了，更多要求规范使用。为实现这已目的，项目搭建离不开Typescript、Eslint、prettier的配置。</p><h3 id="Nodejs项目搭建"><a href="#Nodejs项目搭建" class="headerlink" title="Nodejs项目搭建"></a>Nodejs项目搭建</h3><p>执行<code>npm init -y</code>命令生产<code>package.json</code>文件</p><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><ul><li>安装<code>typescript</code><br>执行命令 <code>npm install typescript --save-dev</code></li><li>安装<code>@types/node</code><br>执行命令 <code>npm install @types/node --save-dev</code></li><li>生成<code>tsconfig.json</code>文件<br>执行命令 <code>npx tsc --init</code>，常见配置见<a href="https://www.typescriptlang.org/zh/docs/handbook/tsconfig-json.html">tsconfig配置</a><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;./src&quot;</span>,       <span class="regexp">//</span> 读取ts文件根目录</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,       <span class="regexp">//</span> 生成js文件路径</span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: true,   <span class="regexp">//</span> 生成js文件时移除注释</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;node_modules&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>安装<code>ts-node</code><br>执行命令 <code>npm install ts-node --save-dev</code>, <a href="https://typestrong.org/ts-node/">ts-node</a>可以运行时解析<code>ts</code>文件，无需转换成js运行。</li><li>配置<code>nodemon</code><br>新建<code>nodemon.json</code>文件<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;watch&quot;</span>: [<span class="string">&quot;src&quot;</span>],</span><br><span class="line">  <span class="string">&quot;ext&quot;</span>: <span class="string">&quot;.ts,.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ignore&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;exec&quot;</span>: <span class="string">&quot;ts-node ./src/index.ts&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>package.json</code>中配置<code>scripts</code>命令<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;<span class="keyword">build</span><span class="string">&quot;: &quot;</span>tsc<span class="string">&quot;,</span></span><br><span class="line"><span class="string">&quot;</span>prestart<span class="string">&quot;: &quot;</span>npm run <span class="keyword">build</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">&quot;</span><span class="keyword">start</span><span class="string">&quot;: &quot;</span>node ./dist/<span class="keyword">index</span>.js<span class="string">&quot;,</span></span><br><span class="line"><span class="string">&quot;</span><span class="keyword">start</span>:dev<span class="string">&quot;: &quot;</span>nodemon<span class="string">&quot;,</span></span><br><span class="line"><span class="string">&quot;</span>lint<span class="string">&quot;: &quot;</span>eslint . --ext .js,.ts<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><ul><li>初始化<code>Eslint</code><br>执行命令 <code>npx eslint --init</code>，然后根据自己需求选择配置</li><li>配置<code>.eslintrc.js</code>文件<br><code>.eslintrc.js</code>文件是配置文件，如果某些想忽略，可以新建文件<code>.eslintignor</code>，写入想要忽略的文件路径</li></ul><h3 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h3><ul><li>安装依赖<br>执行命令<code>npm install eslint-config-prettier eslint-plugin-prettier --save-dev</code>安装 <a href="https://github.com/prettier/eslint-config-prettier#readme">eslint-config-prettier</a>、<a href="https://github.com/prettier/eslint-plugin-prettier#readme">eslint-plugin-prettier</a>即可</li><li>修改<code>.eslintrc.js</code>文件<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extends: [..., <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>],</span><br><span class="line">overrides: [],</span><br><span class="line">parserOptions: &#123;</span><br><span class="line">  ecmaVersion: <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">  sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  project: <span class="string">&#x27;./tsconfig.json&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li>常见<code>prettier</code>配置<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // <span class="number">1.</span>一行代码的最大字符数，默认是<span class="number">80</span>(printWidth: &lt;<span class="type">int</span>&gt;)</span><br><span class="line">  printWidth: <span class="number">80</span>,</span><br><span class="line">  // <span class="number">2.</span>tab宽度为<span class="number">2</span>空格(tabWidth: &lt;<span class="type">int</span>&gt;)</span><br><span class="line">  tabWidth: <span class="number">2</span>,</span><br><span class="line">  // <span class="number">3.</span>是否使用tab来缩进，我们使用空格(useTabs: &lt;<span class="type">bool</span>&gt;)</span><br><span class="line">  useTabs: <span class="keyword">false</span>,</span><br><span class="line">  // <span class="number">4.</span>结尾是否添加分号，<span class="keyword">false</span>的情况下只会在一些导致ASI错误的其工况下在开头加分号，我选择无分号结尾的风格(semi: &lt;<span class="type">bool</span>&gt;)</span><br><span class="line">  semi: <span class="keyword">false</span>,</span><br><span class="line">  // <span class="number">5.</span>使用单引号(singleQuote: &lt;<span class="type">bool</span>&gt;)</span><br><span class="line">  singleQuote: <span class="keyword">true</span>,</span><br><span class="line">  // <span class="number">6.</span><span class="keyword">object</span>对象中key值是否加引号（quoteProps: &quot;&lt;as-needed|consistent|preserve&gt;&quot;）<span class="keyword">as</span>-needed只有在需求要的情况下加引号，consistent是有一个需要引号就统一加，preserve是保留用户输入的引号</span><br><span class="line">  quoteProps: <span class="string">&#x27;as-needed&#x27;</span>,</span><br><span class="line">  // <span class="number">7.</span>在jsx文件中的引号需要单独设置（jsxSingleQuote: &lt;<span class="type">bool</span>&gt;）</span><br><span class="line">  jsxSingleQuote: <span class="keyword">false</span>,</span><br><span class="line">  // <span class="number">8.</span>尾部逗号设置，es5是尾部逗号兼容es5，<span class="keyword">none</span>就是没有尾部逗号，<span class="keyword">all</span>是指所有可能的情况，需要node8和es2017以上的环境。（trailingComma: &quot;&lt;es5|none|all&gt;&quot;）</span><br><span class="line">  trailingComma: <span class="string">&#x27;es5&#x27;</span>,</span><br><span class="line">  // <span class="number">9.</span><span class="keyword">object</span>对象里面的key和<span class="keyword">value</span>值和括号间的空格(bracketSpacing: &lt;<span class="type">bool</span>&gt;)</span><br><span class="line">  bracketSpacing: <span class="keyword">true</span>,</span><br><span class="line">  // <span class="number">10.</span>jsx标签多行属性写法时，尖括号是否另起一行(jsxBracketSameLine: &lt;<span class="type">bool</span>&gt;)</span><br><span class="line">  jsxBracketSameLine: <span class="keyword">false</span>,</span><br><span class="line">  // <span class="number">11.</span>箭头函数单个参数的情况是否省略括号，默认<span class="keyword">always</span>是总是带括号（arrowParens: &quot;&lt;always|avoid&gt;&quot;）</span><br><span class="line">  arrowParens: <span class="string">&#x27;always&#x27;</span>,</span><br><span class="line">  // <span class="number">12.</span>range是<span class="keyword">format</span>执行的范围，可以选执行一个文件的一部分，默认的设置是整个文件（range<span class="keyword">Start</span>: &lt;<span class="type">int</span>&gt;  range<span class="keyword">End</span>: &lt;<span class="type">int</span>&gt;）</span><br><span class="line">  range<span class="keyword">Start</span>: <span class="number">0</span>,</span><br><span class="line">  range<span class="keyword">End</span>: <span class="keyword">Infinity</span>,</span><br><span class="line">  // <span class="number">18.</span> vue script和style标签中是否缩进,开启可能会破坏编辑器的代码折叠</span><br><span class="line">  vueIndentScriptAndStyle: <span class="keyword">false</span>,</span><br><span class="line">  // <span class="number">19.</span>    endOfLine: &quot;&lt;lf|crlf|cr|auto&gt;&quot; 行尾换行符,默认是lf,</span><br><span class="line">  endOfLine: <span class="string">&#x27;lf&#x27;</span>,</span><br><span class="line">  // <span class="number">20.</span>embeddedLanguageFormatting: &quot;off&quot;,默认是auto,控制被引号包裹的代码是否进行格式化</span><br><span class="line">  embeddedLanguageFormatting: <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="文档资料"><a href="#文档资料" class="headerlink" title="文档资料"></a>文档资料</h3><ul><li><a href="https://www.typescriptlang.org/zh/">Typescript</a></li><li><a href="https://zh-hans.eslint.org/">Eslint</a></li><li><a href="https://prettier.io/docs/en/index.html">Prettier</a></li><li><a href="https://github.com/remy/nodemon/#readme">nodemon</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;现代化的工程项目搭建，已经不仅仅满足于可以用了，更多要求规范使用。为实现这已目的，项目搭建离不开Typescript、Eslint、pret
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yunzaifei.github.io/categories/nodejs/"/>
    
    
      <category term="nodejs" scheme="http://yunzaifei.github.io/tags/nodejs/"/>
    
      <category term="typescript" scheme="http://yunzaifei.github.io/tags/typescript/"/>
    
      <category term="eslint" scheme="http://yunzaifei.github.io/tags/eslint/"/>
    
      <category term="prettier" scheme="http://yunzaifei.github.io/tags/prettier/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://yunzaifei.github.io/2022/05/05/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://yunzaifei.github.io/2022/05/05/Docker入门/</id>
    <published>2022-05-05T03:48:36.000Z</published>
    <updated>2022-05-30T01:24:26.605Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。<br>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p><p>官网文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a><br>官方仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h2><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><h2 id="Dcoker基本概念"><a href="#Dcoker基本概念" class="headerlink" title="Dcoker基本概念"></a>Dcoker基本概念</h2><p>Docker 包括三个基本概念：</p><ul><li>镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）：仓库（Repository）类似Git的远程仓库，集中存放镜像文件。</li></ul><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p><img src="https://i.imgur.com/C2xXMGj.jpg" alt="https://i.imgur.com/C2xXMGj.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;br&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;br&gt;容器是完全使用沙箱机制
      
    
    </summary>
    
      <category term="Docker" scheme="http://yunzaifei.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yunzaifei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 入门</title>
    <link href="http://yunzaifei.github.io/2020/06/14/GraphQL%E5%85%A5%E9%97%A8/"/>
    <id>http://yunzaifei.github.io/2020/06/14/GraphQL入门/</id>
    <published>2020-06-14T00:46:38.000Z</published>
    <updated>2020-06-14T01:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>GraphQL既是一种用于API的查询语言也是一个满足你数据查询的运行时。 GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><p>GraphQL官网：<a href="https://graphql.org/">https://graphql.org</a></p><p>GraphQL中文文档：<a href="https://graphql.cn/">https://graphql.cn</a></p><p><code>Apollo GraphQL</code>：<a href="https://www.apollographql.com/docs">https://www.apollographql.com/docs</a></p><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。</p><p>一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是 me，这个用户的名称可能像这样：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Query</span> &#123;</span><br><span class="line">  me: <span class="type">User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="type">User</span> &#123;</span><br><span class="line">  id: <span class="type">ID</span></span><br><span class="line">  name: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一并的还有每个类型上字段的解析函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">Query_me</span>(request) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">request.auth.user</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">User_name</span>(user) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">user.getName()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。<br>例如这个查询：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">me</span> &#123;</span><br><span class="line">    <span class="built_in">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会产生这样的JSON结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;me&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Luke Skywalker&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GraphQL&quot;&gt;&lt;a href=&quot;#GraphQL&quot; class=&quot;headerlink&quot; title=&quot;GraphQL&quot;&gt;&lt;/a&gt;GraphQL&lt;/h3&gt;&lt;p&gt;GraphQL既是一种用于API的查询语言也是一个满足你数据查询的运行时。 GraphQL对你的AP
      
    
    </summary>
    
      <category term="GraphQL" scheme="http://yunzaifei.github.io/categories/GraphQL/"/>
    
    
      <category term="GraphQL" scheme="http://yunzaifei.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Redux简介</title>
    <link href="http://yunzaifei.github.io/2019/10/31/Redux%E7%AE%80%E4%BB%8B/"/>
    <id>http://yunzaifei.github.io/2019/10/31/Redux简介/</id>
    <published>2019-10-31T02:07:24.000Z</published>
    <updated>2019-10-31T14:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p><p>Redux官网：<a href="https://redux.js.org/">https://redux.js.org/</a></p><p>Redux中文文档：<a href="https://cn.redux.js.org/">https://cn.redux.js.org/</a></p><p>react-redux官网：<a href="https://react-redux.js.org/">https://react-redux.js.org/</a></p><p>Redux视频：<a href="https://egghead.io/courses/getting-started-with-redux">https://egghead.io/courses/getting-started-with-redux</a></p><h4 id="Provide"><a href="#Provide" class="headerlink" title="Provide"></a>Provide</h4><p>全局引入<code>react-redux</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  rootElement</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>组件中使用<code>react-redux</code></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; <span class="keyword">from</span> &#x27;react-redux&#x27;</span><br><span class="line">import &#123; increment, decrement, reset &#125; <span class="keyword">from</span> &#x27;./actionCreators&#x27;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">const</span> Counter = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = (<span class="keyword">state</span> /*, ownProps*/) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: <span class="keyword">state</span>.counter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123; increment, decrement, reset &#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p>redux-thunk就是redux的中间件，中间件就是你可以在收到请求和返回请求之间做一些操作。</p><p>github地址：<a href="https://github.com/reduxjs/redux-thunk">https://github.com/reduxjs/redux-thunk</a></p><p>用法，在<code>store.js</code>文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-devtools-extension&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initializeStore = <span class="function">(<span class="params">initialState = &#123;&#125;</span>) =&gt;</span> createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initialState,</span><br><span class="line">  process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? applyMiddleware(thunkMiddleware)</span><br><span class="line">    : composeWithDevTools(applyMiddleware(thunkMiddleware)),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> initializeStore;</span><br></pre></td></tr></table></figure><p>redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>: ADD_COUNT&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addCountAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">           dispatch(addCount())</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><h4 id="useSelector"><a href="#useSelector" class="headerlink" title="useSelector"></a>useSelector</h4><p>基本用法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React <span class="keyword">from</span> &#x27;react&#x27;</span><br><span class="line">import &#123; useSelector &#125; <span class="keyword">from</span> &#x27;react-redux&#x27;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">const</span> CounterComponent = () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useSelector(<span class="keyword">state</span> =&gt; <span class="keyword">state</span>.counter)</span><br><span class="line">  return <span class="variable">&lt;div&gt;</span>&#123;counter&#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="useDispatch"><a href="#useDispatch" class="headerlink" title="useDispatch"></a>useDispatch</h4><p>基本用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CounterComponent = <span class="function">(<span class="params">&#123; value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> dispatch(&#123; <span class="attr">type</span>: <span class="string">&#x27;increment-counter&#x27;</span> &#125;)&#125;&gt;</span><br><span class="line">        Increment counter</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h3&gt;&lt;p&gt;Redux 是 JavaScript 状态容器，提供可预测化的状态管理。&lt;/p&gt;
&lt;p&gt;Redux官网：&lt;a hre
      
    
    </summary>
    
      <category term="Redux" scheme="http://yunzaifei.github.io/categories/Redux/"/>
    
    
      <category term="Redux" scheme="http://yunzaifei.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Nextjs简介</title>
    <link href="http://yunzaifei.github.io/2019/09/21/Nextjs%E7%AE%80%E4%BB%8B/"/>
    <id>http://yunzaifei.github.io/2019/09/21/Nextjs简介/</id>
    <published>2019-09-21T08:45:02.000Z</published>
    <updated>2019-10-31T14:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nextjs"><a href="#Nextjs" class="headerlink" title="Nextjs"></a>Nextjs</h3><p><code>next.js</code>是一个非常棒的轻量级的<code>react</code>同构框架，使用它可以快速的开发出基于服务端渲染的<code>react</code>应用。</p><p>Nextjs官网：<a href="https://nextjs.org/">https://nextjs.org/</a></p><p>Nextjs官方demo：<a href="https://github.com/zeit/next.js/tree/canary/examples">https://github.com/zeit/next.js/tree/canary/examples</a></p><p>Nextjs中文文档：<a href="https://nextjs.frontendx.cn/">https://nextjs.frontendx.cn/</a></p><h4 id="路由处理"><a href="#路由处理" class="headerlink" title="路由处理"></a>路由处理</h4><p>官方文档：<a href="https://nextjs.org/docs#routing">https://nextjs.org/docs#routing</a></p><p>页面中直接跳转用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;Home&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link href=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">            &lt;a&gt;About Us&lt;/a&gt;</span><br><span class="line">          &lt;/Link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">      &lt;h1&gt;This is our homepage.&lt;/h1&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><p>js方法中跳转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadMore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Click &lt;span onClick=&#123;<span class="function">() =&gt;</span> Router.push(<span class="string">&#x27;/about&#x27;</span>)&#125;&gt;here&lt;/span&gt; to read more</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReadMore</span><br></pre></td></tr></table></figure><h4 id="Dynamic-Import"><a href="#Dynamic-Import" class="headerlink" title="Dynamic Import"></a>Dynamic Import</h4><p>官方文档：<a href="https://nextjs.org/docs#dynamic-import">https://nextjs.org/docs#dynamic-import</a></p><p>因为Nextjs代码跑起来会走两套环境，分别是客户端和服务端环境，客户端环境和常规<code>react</code>开发一样，服务端环境就比较麻烦，<code>window</code>，<code>localStorage</code>，<code>navigator.userAgent</code>这些就会在服务端报<code>undefined</code>错误。所以需要控制好代码有哪些是在两个环境通用，哪些只能在客户端环境运行。</p><p>比较常见的就是视频播放，视频播放器即不需要也没办法在服务端渲染，那么如何控制它只在客户端渲染？Nextjs提供了<code>Dynamic Import</code>方法来处理该问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">&#x27;next/dynamic&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DynamicComponentWithNoSSR = dynamic(</span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">&#x27;../components/hello3&#x27;</span>),</span><br><span class="line">  &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;DynamicComponentWithNoSSR /&gt;</span><br><span class="line">      &lt;p&gt;HOME PAGE is here!&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><p>官方文档：<a href="https://nextjs.org/docs#custom-configuration">https://nextjs.org/docs#custom-configuration</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Nextjs&quot;&gt;&lt;a href=&quot;#Nextjs&quot; class=&quot;headerlink&quot; title=&quot;Nextjs&quot;&gt;&lt;/a&gt;Nextjs&lt;/h3&gt;&lt;p&gt;&lt;code&gt;next.js&lt;/code&gt;是一个非常棒的轻量级的&lt;code&gt;react&lt;/code&gt;同构框架，
      
    
    </summary>
    
      <category term="Nextjs" scheme="http://yunzaifei.github.io/categories/Nextjs/"/>
    
    
      <category term="Nextjs" scheme="http://yunzaifei.github.io/tags/Nextjs/"/>
    
  </entry>
  
  <entry>
    <title>Callback,Promise和Async/Await</title>
    <link href="http://yunzaifei.github.io/2019/08/15/Callback-Promise%E5%92%8CAsync-Await/"/>
    <id>http://yunzaifei.github.io/2019/08/15/Callback-Promise和Async-Await/</id>
    <published>2019-08-15T03:48:18.000Z</published>
    <updated>2019-10-31T14:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是单线程语言，但是js中有很多任务耗时比较长，比如ajax请求，如果都按照顺序进行，往往会出现浏览器无响应的情况，所以就需要异步的形式。JS中所有的任务可以分为两种：同步任务和异步任务。</p><ul><li><p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p></li><li><p>异步任务：不进入主线程，而进入任务队列中的任务，只有任务队列通知主线程，某个异步任务可以执行了，这个任务才会进入主线程执行。</p></li><li><p>事件循环（Event Loop）：只有执行栈中的所有同步任务都执行完毕，系统才会读取任务队列，看看里面的异步任务哪些可以执行，然后那些对应的异步任务，结束等待状态，进入执行栈，开始执行。</p></li></ul><h3 id="CallBack"><a href="#CallBack" class="headerlink" title="CallBack"></a>CallBack</h3><p>回调函数本身是我们约定俗成的一种叫法，我们定义它，但是并不会立即执行它，它最终在其他地方执行了。</p><ul><li>优点：比较容易理解；</li><li>缺点：1.高耦合，维护困难，回调地狱; 2.每个任务只能指定一个回调函数; 3.如果几个异步操作之间并没有顺序之分，同样也要等待上一个操作执行结束再进行下一个操作。</li></ul><p>回调地狱：<br><img src="https://image-static.segmentfault.com/293/438/2934385721-5a77b60eb05b0"></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>promise对象的构造函数语法为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="constructor">Promise(<span class="params">function</span>(<span class="params">resolve</span>, <span class="params">reject</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// executor (the producing code, &quot;singer&quot;)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它的参数<code>resolve</code>和<code>reject</code>是JavaScript本身提供的回调。我们的代码仅在执行程序内部。当代码执行完后，它应用调用以下回调之一：</p><ul><li>resolve(value)—如果成功完成，结果为value。</li><li>reject(error)—如果发生错误，error则是错误对象。</li></ul><h5 id="Promise-then-catch-finally"><a href="#Promise-then-catch-finally" class="headerlink" title="Promise.then .catch .finally"></a>Promise.then .catch .finally</h5><p><code>Promise.then</code>相当于执行callback，不过比起callback的嵌套模式，<code>Promise.then().then().then()...</code>的链式写法看起来更直观和美观。</p><p><code>catch</code>，<code>finally</code>的用法相当于<code>try...catch...finally</code></p><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3><p>假如，一个页面中的很多方法都依赖于一个异步函数值的结果，又不想把写好的许多方法放到<code>Promise.the</code>中处理，这个时候你急切得需要一个把异步函数转换成同步函数处理的方式，这个时候<code>async/await</code>方法应运而生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// executor (the producing code, &quot;singer&quot;)</span></span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = res;</span><br><span class="line">    ....</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(errr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">do</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> promise();</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = res;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(errr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript是单线程语言，但是js中有很多任务耗时比较长，比如ajax请求，如果都按照顺序进行，往往会出现浏览器无响应的情况，所以就需要异步的形式。JS中所有的任务可以分为两种：同步任务和异步任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步任务：在主线程上排队执行的任务
      
    
    </summary>
    
      <category term="javascript" scheme="http://yunzaifei.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yunzaifei.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>PWA实战（4）—Notification</title>
    <link href="http://yunzaifei.github.io/2018/09/12/PWA%E5%AE%9E%E6%88%98%EF%BC%884%EF%BC%89%E2%80%94Notification/"/>
    <id>http://yunzaifei.github.io/2018/09/12/PWA实战（4）—Notification/</id>
    <published>2018-09-12T09:21:43.000Z</published>
    <updated>2018-10-31T14:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>推送通知 ( Push Notification )或者也可以称作推播，有智慧手机的人我想应该非常熟悉，尤其是App盛行的时期几乎每只App都会有推送通知功能，这也是恶梦的开始，你会发觉在大半夜里你的手机会三不五时地叫你起床，所以现在的手机几乎都内建了勿扰模式，让使用者可以设定每天的某个时段可以封锁特定的讯息通知，甚至现在的系统都可以让使用用决定App允许那些权限。</p><blockquote><p>推送通知就像一把双刃剑，懂得善用它可以提升用户体验，反之，若滥用它则会让使用者观感不好。</p></blockquote><h3 id="体验pwa推送"><a href="#体验pwa推送" class="headerlink" title="体验pwa推送"></a>体验pwa推送</h3><p>这个网站可以让你体验一下pwa推送，可以在pc和手机上分别体验。<br>链接：<a href="https://web-push-book.gauntface.com/demos/notification-examples/">https://web-push-book.gauntface.com/demos/notification-examples/</a></p><h3 id="推送通知条款"><a href="#推送通知条款" class="headerlink" title="推送通知条款"></a>推送通知条款</h3><ul><li>通知 - 在应用程序的普通用户界面（即浏览器）之外向用户显示的消息</li><li>推送消息 - 从服务器发送到客户端的消息</li><li>推送通知 - 响应推送消息而创建的通知</li><li>通知API - 用于配置和向用户显示通知的界面</li><li>Push API - 用于将应用程序订阅到推送服务并在服务工作者中接收推送消息的接口</li><li>Web Push - 一个非正式术语，指的是将消息从服​​务器推送到Web上的客户端过程中涉及的过程或组件</li><li>推送服务 - 用于将推送消息从服务器路由到客户端的系统。每个浏览器都实现自己的推送服务。</li><li>Web推送协议 - 描述应用程序服务器或用户代理如何与推送服务交互</li></ul><h3 id="实战操作"><a href="#实战操作" class="headerlink" title="实战操作"></a>实战操作</h3><p>参考链接：<a href="https://developers.google.com/web/fundamentals/codelabs/push-notifications/?hl=zh-cn">https://developers.google.com/web/fundamentals/codelabs/push-notifications/?hl=zh-cn</a></p><p>练习源码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/GoogleChrome/</span>push-notifications.git</span><br></pre></td></tr></table></figure><p>模拟推送服务器：<a href="https://web-push-codelab.glitch.me/">https://web-push-codelab.glitch.me/</a></p><h3 id="推送服务"><a href="#推送服务" class="headerlink" title="推送服务"></a>推送服务</h3><p>实际应用中，需要搭建推送服务负责想客户端推送消息<br>网络推送库：<a href="https://github.com/web-push-libs/">https://github.com/web-push-libs/</a><br>nodejs使用的web-push库：<a href="https://www.npmjs.com/package/web-push">https://www.npmjs.com/package/web-push</a></p><h3 id="关于墙的问题"><a href="#关于墙的问题" class="headerlink" title="关于墙的问题"></a>关于墙的问题</h3><p>推送服务的流程类似于，自己搭建的推送服务发送通知到浏览器厂商搭建的推送服务，浏览器厂商搭建的推送服务识别后发送到对应的浏览器客户端。这个过程依赖浏览器厂商搭建的推送服务。目前对pwa推送规范支持最好的有chrom浏览器和firefox浏览器，因为墙的原因，chrome浏览器的推送服务无法送达，但firefox没有任何问题。所以想使用pwa推送的话，建议用户使用firefox浏览器就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推送通知 ( Push Notification )或者也可以称作推播，有智慧手机的人我想应该非常熟悉，尤其是App盛行的时期几乎每只App都会有推送通知功能，这也是恶梦的开始，你会发觉在大半夜里你的手机会三不五时地叫你起床，所以现在的手机几乎都内建了勿扰模式，让使用者可以
      
    
    </summary>
    
      <category term="PWA" scheme="http://yunzaifei.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://yunzaifei.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA实战（3）—Manifest</title>
    <link href="http://yunzaifei.github.io/2018/08/23/PWA%E5%AE%9E%E6%88%98%EF%BC%883%EF%BC%89%E2%80%94Manifest/"/>
    <id>http://yunzaifei.github.io/2018/08/23/PWA实战（3）—Manifest/</id>
    <published>2018-08-23T02:03:46.000Z</published>
    <updated>2018-10-31T14:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Manifest</code>是一个 JSON 文件，您（即开发者）可以利用它控制在用户想要看到应用的区域（例如移动设备主屏幕）中如何向用户显示网络应用或网站，指示用户可以启动哪些功能，以及定义其在启动时的外观。</p><p><code>Manifest</code>提供了将网站书签保存到设备主屏幕的功能。当网站以这种方式启动时：</p><ul><li>它具有唯一的图标和名称，以便用户将其与其他网站区分开来。</li><li>它会在下载资源或从缓存恢复资源时向用户显示某些信息。</li><li>它会向浏览器提供默认显示特性，以避免网站资源可用时的过渡过于生硬。</li></ul><p>它通过一个文本文件中的元数据这一简单机制完成所有这些工作。实现：</p><ul><li>创建清单并将其链接到您的页面，这是非常简单的过程。</li><li>控制用户从主屏幕启动时看到的内容。</li><li>这包括启动画面、主题颜色以及打开的网址等。</li></ul><h3 id="创建清单"><a href="#创建清单" class="headerlink" title="创建清单"></a>创建清单</h3><p>在对网络应用清单做详细探究之前，让我们先创建一个基本清单，然后为其链接一个网页。</p><p>不管您要什么，都可以调用清单。大多数人使用<code>manifest.json</code>。下面是一个示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;short_name&quot;</span>: <span class="string">&quot;AirHorner&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Kinlan&#x27;s AirHorner of Infamy&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;icons&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;src&quot;</span>: <span class="string">&quot;launcher-icon-1x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span>: <span class="string">&quot;48x48&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;src&quot;</span>: <span class="string">&quot;launcher-icon-2x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span>: <span class="string">&quot;96x96&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;src&quot;</span>: <span class="string">&quot;launcher-icon-4x.png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sizes&quot;</span>: <span class="string">&quot;192x192&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;start_url&quot;</span>: <span class="string">&quot;index.html?launcher=true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保包括以下内容：</p><ul><li>在用户主屏幕上用作文本的<code>short_name</code>。</li><li>在网络应用安装横幅中使用的<code>name</code>。</li></ul><h3 id="将清单的相关信息告知浏览器"><a href="#将清单的相关信息告知浏览器" class="headerlink" title="将清单的相关信息告知浏览器"></a>将清单的相关信息告知浏览器</h3><p>在您创建清单且将清单添加到您的网站之后，将<code>link</code>标记添加到包含网络应用的所有页面上，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">&quot;manifest&quot;</span> <span class="attribute">href</span>=<span class="string">&quot;/manifest.json&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="设置启动网址"><a href="#设置启动网址" class="headerlink" title="设置启动网址"></a>设置启动网址</h3><p>如果您不提供<code>start_url</code>，则将使用当前页面，这不太可能是您的用户想要的内容。 但这并不是将它包括在内的唯一原因。 由于您现在可以定义应用的启动方式，因此可向<code>start_url</code>添加一个查询字符串参数来说明其启动方式。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;start_url&quot;</span>: <span class="string">&quot;/?utm_source=homescreen&quot;</span></span><br></pre></td></tr></table></figure><p>这可以是您希望的任何内容；我们要使用的值的优点是对网站统计十分有意义。</p><h3 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h3><p>当用户将您的网站添加到其主屏幕时，您可以定义一组供浏览器使用的图标。您可以通过类型和大小定义它们，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;icons&quot;: [&#123;</span><br><span class="line">    <span class="string">&quot;src&quot;</span>: <span class="string">&quot;images/touch/icon-128x128.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sizes&quot;</span>: <span class="string">&quot;128x128&quot;</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;<span class="attribute">src</span>&quot;: <span class="string">&quot;images/touch/apple-touch-icon.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sizes&quot;</span>: <span class="string">&quot;152x152&quot;</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;<span class="attribute">src</span>&quot;: <span class="string">&quot;images/touch/ms-touch-icon-144x144-precomposed.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sizes&quot;</span>: <span class="string">&quot;144x144&quot;</span></span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    &quot;<span class="attribute">src</span>&quot;: <span class="string">&quot;images/touch/chrome-touch-icon-192x192.png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;image/png&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sizes&quot;</span>: <span class="string">&quot;192x192&quot;</span></span><br><span class="line">  &#125;],</span><br></pre></td></tr></table></figure><h3 id="添加启动画面"><a href="#添加启动画面" class="headerlink" title="添加启动画面"></a>添加启动画面</h3><p>当您从主屏幕启动网络应用时，幕后执行了若干操作：</p><ol><li>Chrome 启动。</li><li>显示页面的渲染器启动。</li><li>您的网站从网络（如果网站有服务工作线程，则从缓存）加载。</li></ol><p>执行以上操作时，屏幕显示为白色并且看似已经停滞。如果您从网络加载网页时页面需要花费不止一两秒的时间才能让首页显现任何内容，这种情况将变得尤为明显。</p><p>为提供更优质的用户体验，您可以用标题、颜色和图像来替换白色屏幕。</p><h4 id="设置图像和标题"><a href="#设置图像和标题" class="headerlink" title="设置图像和标题"></a>设置图像和标题</h4><p>如果您从未落下课程进度，您已应完成了图像和标题的设置。Chrome 会根据清单的特定成员推断图像和标题。此处的要点是了解详情。</p><p>启动画面图像提取自<code>icons</code>数组。Chrome 为设备选择最接近 128dp 的图像。标题是直接从<code>name</code>成员获取的。</p><h4 id="设置背景颜色"><a href="#设置背景颜色" class="headerlink" title="设置背景颜色"></a>设置背景颜色</h4><p>利用适当命名的<code>background_color</code>属性指定背景颜色。 Chrome 在网络应用启动后会立即使用此颜色，这一颜色将保留在屏幕上，直至网络应用首次呈现为止。</p><p>要设置背景颜色，请在您的清单中设置下列内容：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;background_color&quot;</span>: <span class="string">&quot;#2196F3&quot;</span>,</span><br></pre></td></tr></table></figure><p>现在，从主屏幕启动您的网站时将不会呈现白色屏幕。</p><p>该属性的建议适用值是加载页面的背景颜色。使用与加载页面相同的颜色可实现从启动画面到首页的平稳过渡。</p><h4 id="设置主题颜色"><a href="#设置主题颜色" class="headerlink" title="设置主题颜色"></a>设置主题颜色</h4><p>使用<code>theme_color</code>属性指定主题颜色。该属性设置工具栏的颜色。 对此，我们还建议复制某种现有颜色，具体地讲就是<code>theme-color &lt;meta&gt;</code>。</p><h3 id="设置启动样式"><a href="#设置启动样式" class="headerlink" title="设置启动样式"></a>设置启动样式</h3><p>利用网络应用清单来控制显示类型和页面方向。</p><h4 id="自定义显示类型"><a href="#自定义显示类型" class="headerlink" title="自定义显示类型"></a>自定义显示类型</h4><p>您可以通过将<code>display</code>类型设置为<code>standalone</code>，让您的网络应用隐藏浏览器的UI：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;display&quot;</span>: <span class="string">&quot;standalone&quot;</span></span><br></pre></td></tr></table></figure><p>如果您认为用户喜欢在浏览器中像正常网站一样查看您的网页，您可以将<code>display</code>类型设置为<code>browser</code>：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;display&quot;</span>: <span class="string">&quot;browser&quot;</span></span><br></pre></td></tr></table></figure><h4 id="指定页面的初始方向"><a href="#指定页面的初始方向" class="headerlink" title="指定页面的初始方向"></a>指定页面的初始方向</h4><p>您可以强制一个特定方向，这对于某些应用很有用，例如只能在一个方向上运行的游戏。 请有选择地使用。 用户更愿意能够自行选择方向。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;orientation&quot;</span>: <span class="string">&quot;landscape&quot;</span></span><br></pre></td></tr></table></figure><h3 id="提供全站主题颜色"><a href="#提供全站主题颜色" class="headerlink" title="提供全站主题颜色"></a>提供全站主题颜色</h3><p>Chrome 在 2014 年为您的网站引入了主题颜色这一概念。主题颜色是来自您的网页的提示，用于告知浏览器使用什么颜色来为地址栏等 UI 元素着色。</p><p>如果没有清单，您需要在每个页面上定义主题颜色，并且如果您拥有的是大型网站或旧版网站，进行大量全站更改并不可行。<br>向您的清单添加<code>theme_color</code>属性后，从主屏幕启动网站时，网域中的每个页面都将自动获得主题颜色。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;theme_color&quot;</span>: <span class="string">&quot;#2196F3&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Manifest&lt;/code&gt;是一个 JSON 文件，您（即开发者）可以利用它控制在用户想要看到应用的区域（例如移动设备主屏幕）中如何向用户显示网络应用或网站，指示用户可以启动哪些功能，以及定义其在启动时的外观。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Manifest&lt;/c
      
    
    </summary>
    
      <category term="PWA" scheme="http://yunzaifei.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://yunzaifei.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA实战（2）—Service Wroker</title>
    <link href="http://yunzaifei.github.io/2018/08/12/PWA%E5%AE%9E%E6%88%98%EF%BC%882%EF%BC%89%E2%80%94Service-Wroker/"/>
    <id>http://yunzaifei.github.io/2018/08/12/PWA实战（2）—Service-Wroker/</id>
    <published>2018-08-12T13:00:46.000Z</published>
    <updated>2018-10-31T14:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Service-Worker"><a href="#什么是Service-Worker" class="headerlink" title="什么是Service Worker"></a>什么是Service Worker</h3><p>一个<code>Service Worker</code>是一种类型的<code>web worker</code>。它本质上是一个JavaScript文件，它与主浏览器线程分开运行，拦截网络请求，缓存或从缓存中检索资源，以及传递推送消息。</p><p>由于工作者与主线程分开运行，因此<code>Service Worker</code>独立于与其关联的应用程序。这有几个后果：</p><ul><li><p>因为<code>Service Worker</code>没有阻塞（它被设计为完全异步）同步XHR并且localStorage不能在<code>Service Worker</code>中使用。</p></li><li><p>当应用程序未处于活动状态时，<code>Service Worker</code>可以从服务器接收推送消息。这样，即使未在浏览器中打开，您的应用也会向用户显示推送通知。</p></li><li><p><code>Service Worker</code>无法直接访问DOM。为了与页面通信，<code>Service Worker</code>使用<code>postMessage()</code>方法发送数据，并使用<code>message</code>事件监听器来接收数据。</p></li></ul><p>关于<code>Service Worker</code>的注意事项：</p><ul><li><p><code>Service Worker</code>是一种可编程网络代理，可让您控制如何处理来自页面的网络请求。</p></li><li><p><code>Service Worker</code>只能通过HTTPS运行。由于<code>Service Worker</code>可以拦截网络请求并修改响应，因此“中间人”攻击可能非常糟糕。</p><blockquote><p>注意：像<code>Let&#39;s Encrypt</code>这样的服务允许您免费获得SSL证书以便在服务器上安装。</p></blockquote></li><li><p><code>Service Worker</code>工作程序在不使用时变为空闲状态，并在下次需要时重新启动。您不能依赖事件之间持久存在的全局状态。如果存在需要在重新启动时保留和重用的信息，则可以使用<code>IndexedDB</code>数据库。</p></li><li><p><code>Service Worker</code>广泛使用<code>Promises</code>。</p></li></ul><h3 id="Service-Worker能做什么"><a href="#Service-Worker能做什么" class="headerlink" title="Service Worker能做什么"></a>Service Worker能做什么</h3><p><code>Service Worker</code>使应用程序能够控制网络请求，缓存这些请求以提高性能，并提供对缓存内容的脱机访问。</p><p><code>Service Worker</code>依赖于两个API来使应用程序脱机工作： <code>Fetch</code>（从网络检索内容的标准方法）和<code>Cache</code>（应用程序数据的持久内容存储）。这个<code>Cache</code>是持久的，独立于浏览器缓存或网络状态。</p><h4 id="提高应用程序-站点的性能"><a href="#提高应用程序-站点的性能" class="headerlink" title="提高应用程序/站点的性能"></a>提高应用程序/站点的性能</h4><p>缓存资源将使内容在大多数网络条件下加载更快。有关缓存策略的完整列表，请参阅 使用<a href="https://developers.google.com/web/ilt/pwa/lab-caching-files-with-service-worker">Caching files with the service worker</a>和<a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/">The Offline Cookbook</a>。</p><h4 id="让您的应用“离线优先”"><a href="#让您的应用“离线优先”" class="headerlink" title="让您的应用“离线优先”"></a>让您的应用“离线优先”</h4><p>使用<code>Service Worker</code>内部的<code>Fetch API</code>，我们可以拦截网络请求，然后使用所请求资源以外的内容修改响应。当用户离线时，我们可以使用此技术从缓存中提供资源。请参阅 使用<code>Service Worker</code>缓存文件以获得此技术的实际操作经验。</p><h4 id="充当高级功能的基础"><a href="#充当高级功能的基础" class="headerlink" title="充当高级功能的基础"></a>充当高级功能的基础</h4><p><code>Service Worker</code>提供了使Web应用程序像本机应用程序一样工作的功能的起点。其中一些功能是：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Notifications_API">Notifications API</a>：使用操作系统的本机通知系统显示通知并与通信交互的方法。</p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API">Push API</a>：一种API，可让您的应用订阅推送服务并接收推送消息。推送消息被传递给<code>Service Worker</code>，<code>Service Worker</code>可以使用消息中的信息来更新本地状态或向用户显示通知。由于<code>Service Worker</code>独立于主应用程序运行，因此即使浏览器未运行，他们也可以接收和显示通知。</p></li><li><p><a href="https://developers.google.com/web/updates/2015/12/background-sync">Background Sync API</a>：允许您将操作推迟到用户具有稳定连接。这对于确保实际发送用户想要发送的内容非常有用。此API还允许服务器定期更新应用程序，以便应用程序可以在下次联机时进行更新</p></li><li><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Channel_Messaging_API">Channel Messaging API</a>：允许Web工作者和<code>Service Worker</code>相互通信并与主机应用程序通信。此API的示例包括新内容通知和需要用户交互的更新。</p></li></ul><h3 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h3><p><code>Service Worker</code>在其生命周期中经历三个步骤：</p><ul><li>注册</li><li>安装</li><li>激活</li></ul><h4 id="注册和作用域"><a href="#注册和作用域" class="headerlink" title="注册和作用域"></a>注册和作用域</h4><p>要安装<code>Service Worker</code>，您需要在主JavaScript代码中注册它。注册会告诉浏览器您的<code>Service Worker</code>所在的位置，并开始在后台安装它。我们来看一个例子：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> in navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">&#x27;/service-worker.js&#x27;</span>)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(registration)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&#x27;Registration successful, scope is:&#x27;</span>, registration.scope);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&#x27;Service worker registration failed, error:&#x27;</span>, <span class="built_in">error</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码首先检查浏览器支持<code>navigator.serviceWorker</code>。然后向<code>Service Worker</code>注册，<code>navigator.serviceWorker.register</code>返回在<code>Service Worker</code>成功注册时解析的<code>promise</code>，然后用记录<code>registration.scope</code>。</p><p><code>scope</code>是确定哪些<code>Service Worker</code>控制的，换句话说，从该路径的<code>Service Worker</code>将拦截请求。默认范围是<code>Service Worker</code>文件的位置，并扩展到下面的所有目录。因此，如果<code>service-worker.js</code>位于根目录中，则<code>Service Worker</code>将控制来自此域的所有文件的请求。</p><p>您还可以通过在注册时传入其他参数来设置任意范围。例如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;</span><br><span class="line">  scope: &#x27;/app/&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们设置<code>Service Worker</code>的作用域到<code>/app/</code>，这意味着<code>Service Worker</code>作用域包括<code>/app/</code>，<code>/app/lower/</code>以及<code>/app/lower/lower</code>等，但不包括<code>/app</code>或者<code>/</code>，以及其他上一级的路径。</p><p>如果已安装<code>Service Worker</code>，则<code>navigator.serviceWorker.register</code>返回当前<code>Service Worker</code>的注册对象。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一旦浏览器注册了<code>Service Worker</code>，就可以尝试安装。如果浏览器认为<code>Service Worker</code>是新用户，则会安装<code>Service Worker</code>，原因是该站点当前没有已注册的<code>Service Worker</code>，或者因为新<code>Service Worker</code>与之前安装的<code>Service Worker</code>之间存在字节差异。</p><p><code>Service Worker</code>安装会在安装过程中触发事件。我们可以在<code>Service Worker</code>安装过程中包含一个事件监听器，以便在安装<code>Service Worker</code>时执行某些任务。例如，在安装过程中，<code>Service Worker</code>可以预先缓存Web应用程序的某些部分，以便在用户下次打开它时立即加载。因此，在第一次加载之后，您将从即时重复加载中受益，并且在这些情况下，您的交互时间将变得更好。安装事件侦听器的示例如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Listen</span> <span class="keyword">for</span> install event, <span class="keyword">set</span> callback</span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="keyword">function</span>(event) &#123;</span><br><span class="line">    // <span class="keyword">Perform</span> <span class="keyword">some</span> task</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><p>一旦<code>Service Worker</code>成功安装，它就会转换到激活阶段。如果存在由前一个<code>Service Worker</code>控制的任何打开页面，则新<code>Service Worker</code>进入waiting状态。新<code>Service Worker</code>仅在不再加载仍在使用旧<code>Service Worker</code>的任何页面时激活。这可确保在任何给定时间只运行一个版本的<code>Service Worker</code>。</p><blockquote><p>注意：仅刷新页面不足以将控制权转移给新的<code>Service Worker</code>，因为在卸载当前页面之前将请求新页面，并且不会有旧<code>Service Worker</code>未使用的时间。<br>当新<code>Service Worker</code>激活时，将激活的<code>Service Worker</code>中触发事件<code>activate</code>。此事件侦听器是清理过时缓存的好地方</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;activate&#x27;</span>, <span class="keyword">function</span>(event) &#123;</span><br><span class="line">  // <span class="keyword">Perform</span> <span class="keyword">some</span> task</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>激活后，<code>Service Worker</code>将控制在其作用域内加载的所有页面，并开始侦听来自这些页面的事件。但是，在<code>Service Worker</code>激活之前加载的页面不在<code>Service Worker</code>控制之下。新<code>Service Worker</code>只会在您关闭并重新打开应用程序或执行 <code>clients.claim()</code>时接管。在此之前，新<code>Service Worker</code>不会截获此页面的请求。这是有意识的，以确保您的网站的一致性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Service-Worker&quot;&gt;&lt;a href=&quot;#什么是Service-Worker&quot; class=&quot;headerlink&quot; title=&quot;什么是Service Worker&quot;&gt;&lt;/a&gt;什么是Service Worker&lt;/h3&gt;&lt;p&gt;一个&lt;code&gt;Se
      
    
    </summary>
    
      <category term="PWA" scheme="http://yunzaifei.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://yunzaifei.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>PWA实战（1）—概述</title>
    <link href="http://yunzaifei.github.io/2018/07/02/PWA%E5%AE%9E%E6%88%98%EF%BC%881%EF%BC%89%E2%80%94%E6%A6%82%E8%BF%B0/"/>
    <id>http://yunzaifei.github.io/2018/07/02/PWA实战（1）—概述/</id>
    <published>2018-07-02T02:53:57.000Z</published>
    <updated>2018-10-31T14:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是PWA"><a href="#什么是PWA" class="headerlink" title="什么是PWA"></a>什么是PWA</h3><p>PWA（Progressive Web Apps）是渐进式web应用程序，它是2016年，Google I/O 大会上提出的一个概念。这并不是描述一个技术，而是一些技术的合集。PWA是专门应对手机Web开发而提出的，通过新技术的成熟，实现最好的Web + 手机APP。</p><h3 id="PWA特点"><a href="#PWA特点" class="headerlink" title="PWA特点"></a>PWA特点</h3><ul><li><p>可发现：能被识别为应用程序，通过搜索引擎能容易找到。</p></li><li><p>可安装：可用于的移动设备，用户的主屏幕上 - 没有应用程序商店的麻烦。</p></li><li><p>可连接：通过URL轻松共享，无需复杂的安装。</p></li><li><p>网络独立：可工作在离线或低速的网络环境下。</p></li><li><p>渐进增强：适用于所有用户，无论选择什么种类的浏览器。</p></li><li><p>再参与：使用提醒注意让用户更容易的参与，即使用户没有使用他们的设备。</p></li><li><p>响应式：适合任何形式的因素：台式机，手机，平板电脑，或任何随之而来的新设备。</p></li></ul><ul><li>安全：传递机制可以防止监听，并保证内容不被篡改。</li></ul><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><ul><li>Https</li><li>Service Worker</li><li>Web App Manifest</li><li>Push Notification</li></ul><h3 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h3><ul><li><a href="https://h5.ele.me/">饿了么</a></li><li><a href="m.weibo.cn/beta">新浪微博</a></li><li><a href="https://www.flipkart.com/">Flipkart</a></li><li><a href="https://www.instagram.com/">Instagram</a></li><li><a href="https://mobile.twitter.com/">Twitter</a></li><li><a href="https://wiki-offline.jakearchibald.com/">Offline Wikipedia</a></li></ul><p>PWA 资源大全: <a href="https://outweb.io/">Outweb</a>, <a href="https://pwa-directory.appspot.com/">PWA Directory</a></p><p>PWA资料: <a href="https://developers.google.com/web/ilt/pwa/">Google Developers</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是PWA&quot;&gt;&lt;a href=&quot;#什么是PWA&quot; class=&quot;headerlink&quot; title=&quot;什么是PWA&quot;&gt;&lt;/a&gt;什么是PWA&lt;/h3&gt;&lt;p&gt;PWA（Progressive Web Apps）是渐进式web应用程序，它是2016年，Google I/
      
    
    </summary>
    
      <category term="PWA" scheme="http://yunzaifei.github.io/categories/PWA/"/>
    
    
      <category term="PWA" scheme="http://yunzaifei.github.io/tags/PWA/"/>
    
  </entry>
  
  <entry>
    <title>网站使用https，免费方便的Let&#39;s Encrypt证书</title>
    <link href="http://yunzaifei.github.io/2018/05/05/%E7%BD%91%E7%AB%99%E4%BD%BF%E7%94%A8https%EF%BC%8C%E5%85%8D%E8%B4%B9%E6%96%B9%E4%BE%BF%E7%9A%84Let-s-Encrypt%E8%AF%81%E4%B9%A6/"/>
    <id>http://yunzaifei.github.io/2018/05/05/网站使用https，免费方便的Let-s-Encrypt证书/</id>
    <published>2018-05-05T05:54:27.000Z</published>
    <updated>2018-11-10T04:57:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在越来越多的网站升级到https了，并且Chrome和Firefox开始对HTTP网站显示不安全警告，那么如何方便快捷，最好是免费的升级https呢。没错，Let’s Encrypt证书完全能够满足你的所有需求。</p><h3 id="Let’s-Encrypt介绍"><a href="#Let’s-Encrypt介绍" class="headerlink" title="Let’s Encrypt介绍"></a>Let’s Encrypt介绍</h3><p>Let’s Encrypt是一个免费、开放，自动化的证书颁发机构，由 ISRG（Internet Security Research Group）运作。Let’s Encrypt网址：<a href="https://letsencrypt.org/">https://letsencrypt.org/</a></p><p>ISRG是一个关注网络安全的公益组织，其赞助商从非商业组织到财富100强公司都有，包括Mozilla、Akamai、Cisco、Facebook，密歇根大学等等。ISRG以消除资金，技术领域的障碍，全面推进加密连接成为互联网标配为自己的使命。</p><p>Let’s Encrypt项目于2012年由 Mozilla 的两个员工发起，2014年11年对外宣布公开，2015年12月3日开启公测。</p><h3 id="Let’s-Encrypt优势"><a href="#Let’s-Encrypt优势" class="headerlink" title="Let’s Encrypt优势"></a>Let’s Encrypt优势</h3><p>Let’s Encrypt有众多互联网顶级公司的参与，保证了其自身的可信度和可持续性，加上免费这一大杀器，本应该大杀四方，哪里还有那些收费ssl证书的活路。但是，Let’s Encrypt证书的有效期只有90天，到期后需要提交更新，在初期，Let’s Encrypt 的安全证书配置起来比较麻烦，需要手动获取及部署。存在一定的门槛，没有一些技术底子可能比较难搞定。虽然有一些网友就自己做了一些脚本来优化和简化部署过程，但还是有些麻烦不是，并且个人制作的脚本存在一定的使用风险和安全隐患。</p><p>但是，现在Let’s Encrypt官方推出了<a href="https://certbot.eff.org/">Certbot</a>工具，简单敲几行命令就能完成所有配置，并且能够自动续期，妈妈咱已不用惦记90天的问题了。</p><h3 id="Certbot使用"><a href="#Certbot使用" class="headerlink" title="Certbot使用"></a>Certbot使用</h3><p>Certbot网址：<a href="https://certbot.eff.org/">https://certbot.eff.org/</a>,打开网站后看到：</p><p><img src="https://i.imgur.com/8Ivu2xK.jpg" alt="Imgur"></p><p>可以根据操作系统和使用的软件来选择相应的命令，以centos7上的nginx为例：</p><ul><li><h4 id="安装Certbot"><a href="#安装Certbot" class="headerlink" title="安装Certbot"></a>安装Certbot</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot <span class="comment">--nginx</span></span><br></pre></td></tr></table></figure></li><li><h4 id="执行配置命令"><a href="#执行配置命令" class="headerlink" title="执行配置命令"></a>执行配置命令</h4><p>Certbot有一个Nginx插件，它在许多平台上都受支持，并且安装了证书。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot <span class="comment">--nginx</span></span><br></pre></td></tr></table></figure><p>运行此命令将为您获得证书，并让Certbot自动编辑您的Nginx配置以便为其提供服务。如果您感觉更保守，并且想手动更改Nginx配置，则可以使用certonly 子命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot <span class="comment">--nginx certonly</span></span><br></pre></td></tr></table></figure></li><li><h4 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h4><p>Certbot可以配置为在证书过期之前自动续订您的证书。自从让我们将证书最后加密90天后，最好利用此功能。您可以通过运行以下命令来测试证书的自动续订：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot renew <span class="comment">--dry-run</span></span><br></pre></td></tr></table></figure><p>如果工作正常，您可以通过添加运行以下命令的cron job或systemd timer来安排自动续订：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">certbot renew</span></span><br></pre></td></tr></table></figure><p>执行cron命令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo crontab -e</span><br></pre></td></tr></table></figure><p>一个cron的例子可能是这样的，它会在每天的中午和午夜运行：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span>,<span class="number">12</span> * * * certbot renew </span><br></pre></td></tr></table></figure></li><li><h4 id="certbot追加域名"><a href="#certbot追加域名" class="headerlink" title="certbot追加域名"></a>certbot追加域名</h4><p>列出由Certbot管理的所有证书信息</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo certbot certificates</span><br></pre></td></tr></table></figure><p>追加域名</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot --<span class="built_in">expand</span> -d existing.<span class="keyword">com</span> -d example.<span class="keyword">com</span> -d newdomain.<span class="keyword">com</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在越来越多的网站升级到https了，并且Chrome和Firefox开始对HTTP网站显示不安全警告，那么如何方便快捷，最好是免费的升级https呢。没错，Let’s Encrypt证书完全能够满足你的所有需求。&lt;/p&gt;
&lt;h3 id=&quot;Let’s-Encrypt介绍&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx缓存和Gzip压缩设置</title>
    <link href="http://yunzaifei.github.io/2018/01/09/nginx%E7%BC%93%E5%AD%98%E5%92%8CGzip%E5%8E%8B%E7%BC%A9%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yunzaifei.github.io/2018/01/09/nginx缓存和Gzip压缩设置/</id>
    <published>2018-01-09T14:42:58.000Z</published>
    <updated>2018-01-19T15:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 是一个高性能的 Web 服务器，为了提高响应速度，可以从设置 nginx 的 gzip 和缓存这2方面入手。开启 gzip 和缓存能大大减少带宽的消耗。</p><h3 id="开启gzip"><a href="#开启gzip" class="headerlink" title="开启gzip"></a>开启gzip</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启gzip</span></span><br><span class="line">gzip on;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line">gzip_min_length <span class="number">1</span>k;</span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间</span></span><br><span class="line">gzip_comp_level <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span></span><br><span class="line">gzip_types text<span class="regexp">/plain application/</span>javascript application<span class="regexp">/x-javascript text/</span>css application<span class="regexp">/xml text/</span>javascript application<span class="regexp">/x-httpd-php image/</span>jpeg image<span class="regexp">/gif image/</span>png;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用IE 6 gzip</span></span><br><span class="line">gzip_disable <span class="string">&quot;MSIE [1-6]\.&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~* ^.+\.(ico|gif|jpg|jpeg|png)$</span> &#123; </span><br><span class="line">    <span class="attribute">access_log</span>   <span class="literal">off</span>; </span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">30d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* ^.+\.(css|js|txt|xml|swf|wav)$</span> &#123;</span><br><span class="line">    <span class="attribute">access_log</span>   <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">24h</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* ^.+\.(html|htm)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span>      <span class="number">1h</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 是一个高性能的 Web 服务器，为了提高响应速度，可以从设置 nginx 的 gzip 和缓存这2方面入手。开启 gzip 和缓存能大大减少带宽的消耗。&lt;/p&gt;
&lt;h3 id=&quot;开启gzip&quot;&gt;&lt;a href=&quot;#开启gzip&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="Nginx" scheme="http://yunzaifei.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yunzaifei.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>通过Git Hooks实现自动部署</title>
    <link href="http://yunzaifei.github.io/2018/01/02/%E9%80%9A%E8%BF%87Git-Hooks%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://yunzaifei.github.io/2018/01/02/通过Git-Hooks实现自动部署/</id>
    <published>2018-01-02T02:56:35.000Z</published>
    <updated>2018-01-23T03:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在没有接触到Git Hook之前，我一直都是在本地将代码push到远程仓库，然后再ssh到服务器上git pull，想起来都心酸。这样手工操作不仅繁琐，还非常容易出错。好在Git为我们提供了hook这种好东西，能够在特定的事件触发时执行我们写好的脚本，实现自动化部署。</p><h3 id="为什么需要自动化部署？"><a href="#为什么需要自动化部署？" class="headerlink" title="为什么需要自动化部署？"></a>为什么需要自动化部署？</h3><ul><li>当在本地计算机完成服务器应用程序开发之后，需要把程序安装到服务器上，这样的安装过程一般称之为部署。</li><li>部署一般分为文件复制、启动服务、安装依赖等。</li><li>每次开发完成一个版本都需要部署一次。手动部署属于多次重复劳动。</li><li>身为合格的程序员，应该把一切能够自动化的劳动自动化。</li></ul><p>通过Git Hooks实现的自动化部署，将实现敲入git push命令后，自动完成整个部署过程。</p><h3 id="认识Hooks"><a href="#认识Hooks" class="headerlink" title="认识Hooks"></a>认识Hooks</h3><p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Git Hooks</a>提供了多种形式的Hook，以pre-commit为例，该Hook将拦截git commit操作，运行名叫pre-commit的脚本，且仅当脚本返回值为0时进行真正的commit操作。</p><p>那么自动部署所需使用的Hook名为post-receive. 该Hook将在服务器端的bare repository接收到push信息并完成push操作后，进行执行；无法中断客户端（Client）的push过程。</p><p>可能浏览完上面的介绍，还是不太明白Hook是什么。简单地说，Hook是一种特殊的脚本（代码），仅在满足特定条件时执行。Git Hooks分别有对应各种操作的Hook，可以在git repository的.git/hooks目录下看到。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applypatch-msg.<span class="keyword">sample</span>     pre-commit.<span class="keyword">sample</span>         prepare-commit-msg.<span class="keyword">sample</span></span><br><span class="line">commit-msg.<span class="keyword">sample</span>         pre-push.<span class="keyword">sample</span>           <span class="keyword">update</span>.<span class="keyword">sample</span></span><br><span class="line"><span class="keyword">post</span>-<span class="keyword">update</span>.<span class="keyword">sample</span>        pre-rebase.<span class="keyword">sample</span></span><br><span class="line">pre-applypatch.<span class="keyword">sample</span>     pre-receive.<span class="keyword">sample</span></span><br></pre></td></tr></table></figure><p>以上的脚本文件就是Hook了。可以看到脚本文件的后缀名都是sample，也就是说，这些都是Git自带的Hook示例，并不会真正地被执行。要想真正地被执行，只需要去掉sample后缀名即可。例如要启用pre-push的Hook（在push操作前执行脚本，脚本返回值为0时执行push操作），在hooks目录下新建一个pre-push的文件（没有后缀名）。</p><p>在脚本中，你可以写Bash、Python、JavaScript等代码，Git通过<a href="https://zh.wikipedia.org/wiki/Shebang">Shebang</a>来选择执行代码的解释器。如果要写Bash，Shebang可以是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br></pre></td></tr></table></figure><p>使用Windows的读者请注意，如果脚本文件含有BOM（字节序标识符），可能会导致一些问题。</p><p>当完成脚本编写后，Git Hooks便完成了。</p><h3 id="Git-Hooks与自动部署"><a href="#Git-Hooks与自动部署" class="headerlink" title="Git Hooks与自动部署"></a>Git Hooks与自动部署</h3><p>要保证不是git服务端和要部署的网站目录在同一台服务器，并且最好都属于git用户，这样不需要考虑操作权限问题了。</p><ul><li>git hooks部署</li></ul><p>裸仓库接收push之后怎么自动去执行pull操作，git仓库中有个.git文件夹，里面有个hooks文件夹，git 钩子就藏在这。里面有很多文件，其中有个<code>post-receive.sample</code>文件（没有的话也没有关系，新建一个<code>post-receive</code>文件，注意不带sample后缀，带上这个后缀默认是不触发执行的），我们要做的脚本代码就在这里个文件里面完成。</p><p>下面的示例是使用nodejs生成的静态网站，先执行<code>git pull</code>获取最新代码，然后检查node_modules文件夹是否存在，如果不存在，执行<code>npm install</code>命令。然后检查package.json文件，如果变动，执行<code>npm install</code>命令，最后执行<code>npm run build</code>命令生成静态网站文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">WORKTREE=/var/www/xxxweb</span><br><span class="line">CONFIG=package.json</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> oldrev newrev ref <span class="comment"># post-receive 将读取这三个变量</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$ref</span> =~ .*/master$ ]]; <span class="comment"># 仅允许master分支进行部署</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Pull to worktree...&quot;</span></span><br><span class="line">        <span class="comment">#echo &quot;$oldrev $newrev&quot;</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="variable">$WORKTREE</span></span><br><span class="line">        <span class="built_in">unset</span> GIT_DIR</span><br><span class="line">        git pull &amp;&gt; /dev/null</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="string">&quot;/node_modules&quot;</span> ] <span class="comment"># 如果node_modules文件夹不存在</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;install packages...&quot;</span></span><br><span class="line">            npm install</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        git diff --quiet <span class="variable">$oldrev</span> <span class="variable">$newrev</span> -- <span class="variable">$CONFIG</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq <span class="string">&quot;1&quot;</span> ] <span class="comment"># 当package.json被修改时，安装依赖</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;package.json changed&quot;</span></span><br><span class="line">            <span class="built_in">export</span> LC_ALL=C <span class="comment"># 去除所有本地化的设置</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;install packages...&quot;</span></span><br><span class="line">            npm install</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;package.json does not changed&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#如果是需要PM2启动服务</span></span><br><span class="line">        pm2 show api &amp;&gt; /dev/null <span class="comment">#查看PM2是否启动</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;$?&quot;</span> -eq <span class="string">&quot;1&quot;</span> ]</span><br><span class="line">        <span class="keyword">then</span> </span><br><span class="line">            pm2 start app.js -n <span class="string">&#x27;api&#x27;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pm2 restart api</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#如果是生成网页</span></span><br><span class="line">        npm run build <span class="comment"># 生成dist        </span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;build complete&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;This is not master branch, and it will not be deployed&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>对了，编辑完post-receive文件，要赋予其执行权限，<code>chmod +x post-receive</code>，并且改变文件所有者<code>chown git:git post-receive</code>。</p><ul><li>权限处理<br>在上述代码示例中，我部署了的网站工作目录是<code>/var/www/xxxweb</code>，所属用户是git，如果不是，执行<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R g<span class="symbol">it:gi</span><span class="built_in">t</span> xxxweb</span><br></pre></td></tr></table></figure>因为所属用户是git，钩子脚本的所有者也是git，所以权限是没有问题的（如果不是同属于git用户，命令需要sudo，同时需要配置权限，比较麻烦，不建议）。可能有些时候需要在git用户下执行<code>ssh -T git@127.0.0.1</code>添加known_hosts。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在没有接触到Git Hook之前，我一直都是在本地将代码push到远程仓库，然后再ssh到服务器上git pull，想起来都心酸。这样手工操作不仅繁琐，还非常容易出错。好在Git为我们提供了hook这种好东西，能够在特定的事件触发时执行我们写好的脚本，实现自动化部署。&lt;/p
      
    
    </summary>
    
      <category term="Git" scheme="http://yunzaifei.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yunzaifei.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Web API文档生成工具apidoc</title>
    <link href="http://yunzaifei.github.io/2017/12/26/Web-API%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7apidoc/"/>
    <id>http://yunzaifei.github.io/2017/12/26/Web-API文档生成工具apidoc/</id>
    <published>2017-12-26T01:24:52.000Z</published>
    <updated>2017-12-26T01:57:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发过程中，总会牵扯到接口文档的设计与编写，如果使用office工具，写一个文档，总也是不够漂亮和直观。好在git上的开源大神提供了生成文档的工具，so来介绍一下apidoc！</p><p>apidoc可以根据代码注释生成web api文档，支持大部分主流语言java javascript php coffeescript erlang perl python ruby go…，相对而言，web接口的注释维护起来更加方便，不需要额外再维护一份文档。</p><p>apidoc从注释生成静态html网页文档，不仅支持项目版本号，还支持api版本号。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>主页: <a href="http://apidocjs.com/">http://apidocjs.com</a><br>github: <a href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a><br>可以使用<code>npm install apidoc -g</code>进行安装。<br>如果不想使用全局命令，可以使用下面的构建工具：  </p><ul><li><a href="https://pypi.python.org/pypi/flask-apidoc/">flask-apidoc</a> <code>pip install flask-apidoc</code></li><li><a href="https://github.com/apidoc/grunt-apidoc">grunt-apidoc</a> <code>npm install grunt-apidoc</code></li><li><a href="https://github.com/techgaun/gulp-apidoc">gapidoc (gulp)</a> <code>npm install gapidoc</code></li><li><a href="https://github.com/ayhankuru/gulp-apidoc">gulp-apidoc</a> <code>npm install gulp-apidoc</code></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>在命令行窗口执行<code>apidoc -h</code>命令，可以查看帮助。<br>下面讲讲常用的方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 典型用法</span><br><span class="line">apidoc -i api<span class="regexp">/ -o doc/</span>api [-c ./] -f <span class="string">&quot;.*\.js$&quot;</span></span><br><span class="line"></span><br><span class="line">-i 表示输入，后面是文件夹路径</span><br><span class="line">-o 表示输出，后面是文件夹路径</span><br><span class="line">默认会带上-c，在当前路径下寻找配置文件(apidoc.json)，如果找不到则会在package.json中寻找 <span class="string">&quot;apidoc&quot;</span>: &#123; &#125;</span><br><span class="line">-f 为文件过滤，后面是正则表达式，示例为只选着js文件</span><br><span class="line">与-f类似，还有一个 -e 的选项，表示要排除的文件/文件夹，也是使用正则表达式</span><br></pre></td></tr></table></figure><h4 id="配置文件（apidoc-json）"><a href="#配置文件（apidoc-json）" class="headerlink" title="配置文件（apidoc.json）"></a>配置文件（apidoc.json）</h4><p>apidoc.json示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;apiDoc basic example&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Custom apiDoc browser title&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span> : <span class="string">&quot;https://api.github.com/v1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果放入package.json中，相同的字段可以直接使用package.json的定义，额外的字段放入apidoc下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;example&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;apiDoc basic example&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apidoc&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Custom apiDoc browser title&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span> : <span class="string">&quot;https://api.github.com/v1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注释写法"><a href="#注释写法" class="headerlink" title="注释写法"></a>注释写法</h4><p>常用关键字  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@api</span> &#123;method&#125; path <span class="selector-attr">[title]</span></span><br><span class="line">  只有使用<span class="keyword">@api</span>标注的注释块才会在解析之后生成文档，title会被解析为导航菜单(<span class="keyword">@apiGroup</span>)下的小菜单</span><br><span class="line">  method可以有空格，如&#123;POST GET&#125;</span><br><span class="line"><span class="keyword">@apiGroup</span> name</span><br><span class="line">  分组名称，被解析为导航栏菜单</span><br><span class="line"><span class="keyword">@apiName</span> name</span><br><span class="line">  接口名称，在同一个<span class="keyword">@apiGroup</span>下，名称相同的<span class="keyword">@api</span>通过<span class="keyword">@apiVersion</span>区分，否者后面<span class="keyword">@api</span>会覆盖前面定义的<span class="keyword">@api</span></span><br><span class="line"><span class="keyword">@apiDescription</span> text</span><br><span class="line">  接口描述，支持html语法</span><br><span class="line"><span class="keyword">@apiVersion</span> verison</span><br><span class="line">  接口版本，major.minor.patch的形式</span><br><span class="line">  </span><br><span class="line"><span class="keyword">@apiIgnore</span> [hint]</span><br><span class="line">  apidoc会忽略使用<span class="keyword">@apiIgnore</span>标注的接口，hint为描述</span><br><span class="line"><span class="keyword">@apiSampleRequest</span> url</span><br><span class="line">  接口测试地址以供测试，发送请求时，<span class="keyword">@api</span> method必须为POST/GET等其中一种</span><br><span class="line"></span><br><span class="line"><span class="keyword">@apiDefine</span> name [title] [description]</span><br><span class="line">  定义一个注释块(不包含<span class="keyword">@api</span>)，配合<span class="keyword">@apiUse</span>使用可以引入注释块</span><br><span class="line">  在<span class="keyword">@apiDefine</span>内部不可以使用<span class="keyword">@apiUse</span></span><br><span class="line"><span class="keyword">@apiUse</span> name</span><br><span class="line">  引入一个<span class="keyword">@apiDefine</span>的注释块</span><br><span class="line"></span><br><span class="line"><span class="keyword">@apiParam</span> [(group)] [&#123;type&#125;] <span class="selector-attr">[field=defaultValue]</span> <span class="selector-attr">[description]</span></span><br><span class="line"><span class="keyword">@apiHeader</span> [(group)] [&#123;type&#125;] <span class="selector-attr">[field=defaultValue]</span> <span class="selector-attr">[description]</span></span><br><span class="line"><span class="keyword">@apiError</span> [(group)] [&#123;type&#125;] field <span class="selector-attr">[description]</span></span><br><span class="line"><span class="keyword">@apiSuccess</span> [(group)] [&#123;type&#125;] field <span class="selector-attr">[description]</span></span><br><span class="line">  用法基本类似，分别描述请求参数、头部，响应错误和成功</span><br><span class="line">  group表示参数的分组，type表示类型(不能有空格)，入参可以定义默认值(不能有空格)</span><br><span class="line"><span class="keyword">@apiParamExample</span> [&#123;type&#125;] <span class="selector-attr">[title]</span> example</span><br><span class="line"><span class="keyword">@apiHeaderExample</span> [&#123;type&#125;] <span class="selector-attr">[title]</span> example</span><br><span class="line"><span class="keyword">@apiErrorExample</span> [&#123;type&#125;] <span class="selector-attr">[title]</span> example</span><br><span class="line"><span class="keyword">@apiSuccessExample</span> [&#123;type&#125;] <span class="selector-attr">[title]</span> example</span><br><span class="line">  用法完全一致，但是type表示的是example的语言类型</span><br><span class="line">  example书写成什么样就会解析成什么样，所以最好是书写的时候注意格式化，(许多编辑器都有列模式，可以使用列模式快速对代码添加*号)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">@apiPermission</span> name</span><br><span class="line">  name必须独一无二，描述<span class="keyword">@api</span>的访问权限，如admin/anyone</span><br></pre></td></tr></table></figure><p>文档生成后的结果是这样的：<br><a href="http://apidocjs.com/example/">http://apidocjs.com/example/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目开发过程中，总会牵扯到接口文档的设计与编写，如果使用office工具，写一个文档，总也是不够漂亮和直观。好在git上的开源大神提供了生成文档的工具，so来介绍一下apidoc！&lt;/p&gt;
&lt;p&gt;apidoc可以根据代码注释生成web api文档，支持大部分主流语言jav
      
    
    </summary>
    
      <category term="api" scheme="http://yunzaifei.github.io/categories/api/"/>
    
    
      <category term="apidoc" scheme="http://yunzaifei.github.io/tags/apidoc/"/>
    
  </entry>
  
  <entry>
    <title>koa2开发的api服务及jwt应用</title>
    <link href="http://yunzaifei.github.io/2017/09/22/koa2%E5%BC%80%E5%8F%91%E7%9A%84api%E6%9C%8D%E5%8A%A1%E5%8F%8Ajwt%E5%BA%94%E7%94%A8/"/>
    <id>http://yunzaifei.github.io/2017/09/22/koa2开发的api服务及jwt应用/</id>
    <published>2017-09-22T00:56:56.000Z</published>
    <updated>2017-09-24T05:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>koa2开发的api服务示例，使用用jwt验证。</p><p>github代码：<a href="https://github.com/yunzaifei/koa2-jwt-demo">https://github.com/yunzaifei/koa2-jwt-demo</a></p><h2 id="安装及部署"><a href="#安装及部署" class="headerlink" title="安装及部署"></a>安装及部署</h2><ul><li>执行命令npm install</li><li>执行命令npm start启动服务</li><li>可以通过postman等工具对服务进行测试，或者通过npm run test命令使用网页页查看</li></ul><h2 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h2><ul><li>koa2框架</li><li>jwt原理及应用</li><li>mongoose应用</li><li>async/await的简单使用</li></ul><h2 id="知识点讲解"><a href="#知识点讲解" class="headerlink" title="知识点讲解"></a>知识点讲解</h2><h3 id="koa2框架"><a href="#koa2框架" class="headerlink" title="koa2框架"></a>koa2框架</h3><p>koa就是一种简单好用的Web框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合Unix哲学。</p><p>koa官网 <a href="http://koajs.com/">http://koajs.com/</a></p><p>koa中文文档 <a href="https://github.com/guo-yu/koa-guide">https://github.com/guo-yu/koa-guide</a></p><p>koa2进阶学习笔记 <a href="https://chenshenhai.github.io/koa2-note/">https://chenshenhai.github.io/koa2-note/</a></p><h4 id="本示例中涉及的中间件"><a href="#本示例中涉及的中间件" class="headerlink" title="本示例中涉及的中间件"></a>本示例中涉及的中间件</h4><table><thead><tr><th>中间件</th><th>功能说明</th><th>链接</th><th>备注</th></tr></thead><tbody><tr><td>bcrypt</td><td>加密</td><td><a href="https://npmjs.org/package/bcrypt"><img src="https://img.shields.io/npm/v/bcrypt.svg?style=flat-square" alt="NPM version"></a></td><td>用于用户密码存入数据库时</td></tr><tr><td>jsonwebtoken</td><td>jwt实现</td><td><a href="https://npmjs.org/package/jsonwebtoken"><img src="https://img.shields.io/npm/v/jsonwebtoken.svg?style=flat-square" alt="NPM version"></a></td><td></td></tr><tr><td>kcors</td><td>koa跨域</td><td><a href="https://npmjs.org/package/kcors"><img src="https://img.shields.io/npm/v/kcors.svg?style=flat-square" alt="NPM version"></a></td><td></td></tr><tr><td>koa</td><td>koa框架</td><td><a href="https://npmjs.org/package/koa"><img src="https://img.shields.io/npm/v/koa.svg?style=flat-square" alt="NPM version"></a></td><td></td></tr><tr><td>koa-bodyparser</td><td>数据解析到ctx.request.body中</td><td><a href="https://npmjs.org/package/koa-bodyparser"><img src="https://img.shields.io/npm/v/koa-bodyparser.svg?style=flat-square" alt="NPM version"></a></td><td><a href="https://chenshenhai.github.io/koa2-note/note/request/post-use-middleware.html">详细</a></td></tr><tr><td>koa-json</td><td>response转换位json格式</td><td><a href="https://npmjs.org/package/koa-json"><img src="https://img.shields.io/npm/v/koa-json.svg?style=flat-square" alt="NPM version"></a></td><td></td></tr><tr><td>koa-jwt</td><td>jwt自动校验</td><td><a href="https://npmjs.org/package/koa-jwt"><img src="https://img.shields.io/npm/v/koa-jwt.svg?style=flat-square" alt="NPM version"></a></td><td>使用后不用在每个路由下手写校验方法</td></tr><tr><td>koa-logger</td><td>日志</td><td><a href="https://npmjs.org/package/koa-logger"><img src="https://img.shields.io/npm/v/koa-logger.svg?style=flat-square" alt="NPM version"></a></td><td></td></tr><tr><td>koa-router</td><td>路由</td><td><a href="https://npmjs.org/package/koa-router"><img src="https://img.shields.io/npm/v/koa-router.svg?style=flat-square" alt="NPM version"></a></td><td><a href="https://chenshenhai.github.io/koa2-note/note/route/koa-router.html">详细</a></td></tr><tr><td>mongoose</td><td>操作mongodb数据库</td><td><a href="https://npmjs.org/package/mongoose"><img src="https://img.shields.io/npm/v/mongoose.svg?style=flat-square" alt="NPM version"></a></td><td><a href="http://mongoosejs.com/docs/guide.html">文档</a></td></tr></tbody></table><h4 id="代码结构说明"><a href="#代码结构说明" class="headerlink" title="代码结构说明"></a>代码结构说明</h4><p>本示例代码实现api服务，因为没有页面展示功能，所以没有使用<a href="https://www.npmjs.com/package/koa-static">koa-static</a>加载静态资源和创建views视图结构。 </p><p>启动文件是app.js。</p><p>route文件夹是路由服务。 </p><p>config.js文件记录所有配置信息方便统一管理。</p><h3 id="jwt原理及应用"><a href="#jwt原理及应用" class="headerlink" title="jwt原理及应用"></a>jwt原理及应用</h3><h4 id="jwt原理"><a href="#jwt原理" class="headerlink" title="jwt原理"></a>jwt原理</h4><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。注意，在JWT中，不应该在载荷里面加入任何敏感的数据。查看jwt信息：<a href="https://jwt.io/">https://jwt.io/</a></p><p><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/">jwt原理</a></p><p><a href="http://www.cnblogs.com/xiekeli/p/5607107.html">基于Token的WEB后台认证机制</a></p><h4 id="jwt应用"><a href="#jwt应用" class="headerlink" title="jwt应用"></a>jwt应用</h4><p>对于jwt的应用，本示例中主要用到jsonwebtoken<a href="https://npmjs.org/package/jsonwebtoken"><img src="https://img.shields.io/npm/v/jsonwebtoken.svg?style=flat-square" alt="NPM version"></a>和koa-jwt<a href="https://npmjs.org/package/koa-jwt"><img src="https://img.shields.io/npm/v/koa-jwt.svg?style=flat-square" alt="NPM version"></a>两个中间件。koa-jwt是对jsonwebtoken功能的封装，如果想更灵活的实现并且不怕麻烦，可以只使用jsonwebtoken中间件。</p><p>jsonwebtoken用法</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jsonwebtoken在服务端生成token返回给客户端</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> token = jwt.sign(&#123;</span><br><span class="line">    <span class="attribute">id:</span><span class="string"> user._id</span>,</span><br><span class="line">    <span class="attribute">secret</span>: user.app_secret</span><br><span class="line">&#125;, config.jwt_secret, &#123;<span class="attribute">expiresIn</span>: <span class="number">3600</span>&#125;)</span><br><span class="line">    </span><br><span class="line">ctx.body = &#123; </span><br><span class="line">  <span class="attribute">code</span>: <span class="number">200</span>, </span><br><span class="line">  <span class="attribute">message</span>: <span class="string">&#x27;登录成功!&#x27;</span>, </span><br><span class="line">  <span class="attribute">token</span>: token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>koa-jwt用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//koa-jwt在服务端校验从客户端提交的token值</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;koa-jwt&#x27;</span>)</span><br><span class="line">app.use(jwt(&#123;<span class="attr">secret</span>: config.jwt_secret&#125;).unless(&#123;<span class="attr">path</span>:[<span class="regexp">/^\/api\/login/</span>, <span class="regexp">/^\/api\/register/</span>]&#125;)) <span class="comment">//usless排除进行jwt校验的路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在路由中处理</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line">router.post(<span class="string">&#x27;/xxx&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> token = ctx.state.user</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;user_id:&#x27;</span>, token.id)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;user.app_secret:&#x27;</span>, token.secret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mongoose应用"><a href="#mongoose应用" class="headerlink" title="mongoose应用"></a>mongoose应用</h3><p>mongoose文档：<a href="http://mongoosejs.com/docs/guide.html">http://mongoosejs.com/docs/guide.html</a></p><p>mongoose中文文档：<a href="https://mongoose.shujuwajue.com/">https://mongoose.shujuwajue.com/</a></p><h3 id="async-await的简单使用"><a href="#async-await的简单使用" class="headerlink" title="async/await的简单使用"></a>async/await的简单使用</h3><p><a href="http://es6.ruanyifeng.com/#docs/async">async 函数</a></p><p><a href="http://coolcao.com/2016/12/12/deeper-understanding-of-async-await/">深入理解ES7的async/await</a></p><p><a href="https://www.lazycoffee.com/articles/view?id=58ab09eea072b332753d9774">Callback、Promise、Generator、async/await对比</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;koa2开发的api服务示例，使用用jwt验证。&lt;/p&gt;
&lt;p&gt;github代码：&lt;a href=&quot;https://github.com/yunzaifei/koa2-jwt-demo&quot;&gt;https://github.com/yunzaifei/koa2-jwt-demo&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="http://yunzaifei.github.io/categories/nodejs/"/>
    
    
      <category term="koa" scheme="http://yunzaifei.github.io/tags/koa/"/>
    
      <category term="jwt" scheme="http://yunzaifei.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的Git服务器</title>
    <link href="http://yunzaifei.github.io/2017/01/13/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Git%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yunzaifei.github.io/2017/01/13/搭建自己的Git服务器/</id>
    <published>2017-01-13T05:43:47.000Z</published>
    <updated>2018-01-11T15:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Git与常用的版本控制工具CVS, SVN等不同，它采用了分布式版本库的方式，不必服务器端软件支持。Github是一个基于git的代码托管平台，Github公开的项目是免费的，但是如果你不想让其他人看到你的项目就需要收费。这时我们就需要自己搭建一台Git服务器作为私有仓库使用。接下来我们将以Centos 7为例搭建Git服务器,其中Centos 7作为服务端，windows系统作为客户端。</p><h2 id="sever"><a href="#sever" class="headerlink" title="sever"></a>sever</h2><ol><li>安装git<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure></li><li>新建一个linux用户，起名为git（当然也可以叫其他名字）<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd git</span></span><br></pre></td></tr></table></figure></li><li>在git用户目录中新建目录.ssh<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir .ssh</span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">700</span> .ssh</span><br></pre></td></tr></table></figure></li><li>在/home/git/.ssh/目录中新建authorized_keys文件，并将客户端提供的公钥(id_rsa.pub)黏贴到该文件中<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>touch .ssh/authorized_keys</span><br><span class="line"><span class="variable">$ </span>chmod <span class="number">600</span> .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li>创建一个git裸仓库，假如当前项目目录为/home/git/xxx.git<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">--bare xxx.git</span></span><br></pre></td></tr></table></figure></li><li>将项目目录和git用户目录下的.ssh目录的所有者和所属组都设置成git<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R git.git xxx.git  </span><br><span class="line">chown -R git.git <span class="regexp">/home/gi</span>t<span class="regexp">/.ssh/</span></span><br></pre></td></tr></table></figure></li><li>为了安全考虑，禁用git用户的shell登录<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>passwd</span><br><span class="line">注释 ##git:x:<span class="number">000</span>:<span class="number">000</span>::<span class="regexp">/home/gi</span>t:<span class="regexp">/bin/</span>bash (git:x:<span class="number">000</span>:<span class="number">000</span>中数字不要改动，文件中是多少就是多少)</span><br><span class="line">改为 git:x:<span class="number">000</span>:<span class="number">000</span>:git version control:<span class="regexp">/home/gi</span>t:<span class="regexp">/usr/</span>bin/git-shell</span><br></pre></td></tr></table></figure></li><li>git服务器打开RSA认证<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vi</span> /etc/ssh/sshd_config</span><br><span class="line">下面<span class="number">3</span>个打开</span><br><span class="line"> <span class="number">1</span>.RSAAuthentication <span class="literal">yes</span>     </span><br><span class="line"> <span class="number">2</span>.PubkeyAuthentication <span class="literal">yes</span>     </span><br><span class="line"> <span class="number">3</span>.AuthorizedKeysFile  .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ol><h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><ol><li>生成公钥,并复制到服务端authorized_keys文件<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;标识名&quot;</span></span><br><span class="line">ssh-<span class="builtin-name">add</span> -L</span><br></pre></td></tr></table></figure></li><li>在C:/Users/用户名/.ssh下新建config文件，config文件内容<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#注释名称</span><br><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">xxxx</span>(自定义host名称)</span><br><span class="line"><span class="selector-tag">HostName</span> <span class="selector-tag">xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.xxx</span>(服务端ip地址)</span><br><span class="line"><span class="selector-tag">user</span> <span class="selector-tag">git</span>(服务端作为git仓库的用户名)</span><br><span class="line"><span class="selector-tag">Port</span> <span class="selector-tag">22</span>(服务端ssh端口号)</span><br><span class="line"><span class="selector-tag">IdentityFile</span> ~/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span>(默认值为id_rsa，如果个性化名称，请填写个性化的名称)</span><br></pre></td></tr></table></figure></li><li>新建一个文件夹，克隆仓库<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@xxxx(config文件中自定义host名称)：/home/git/xxx.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="常用个git命令"><a href="#常用个git命令" class="headerlink" title="常用个git命令"></a>常用个git命令</h2><ol><li>新建代码库<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure></li><li>配置<br>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ <span class="string">git</span> <span class="string">config</span> <span class="built_in">--list</span></span><br><span class="line"><span class="built_in"></span>  </span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ <span class="string">git</span> <span class="string">config</span> -<span class="string">e</span> [<span class="built_in">--global]</span></span><br><span class="line"><span class="built_in"></span>  </span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ <span class="string">git</span> <span class="string">config</span> [<span class="built_in">--global]</span> <span class="string">user</span>.<span class="string">name</span> <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ <span class="string">git</span> <span class="string">config</span> [<span class="built_in">--global]</span> <span class="string">user</span>.<span class="string">email</span> <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure></li><li>增加/删除文件<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line"><span class="variable">$</span> git add [<span class="type">file1</span>] [<span class="type">file2</span>] ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="variable">$</span> git add [<span class="type">dir</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="variable">$</span> git add .</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="variable">$</span> git add <span class="literal">-p</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> [<span class="type">file1</span>] [<span class="type">file2</span>] ...</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">rm</span> -<span class="literal">-cached</span> [<span class="type">file</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">mv</span> [<span class="type">file</span>-<span class="type">original</span>] [<span class="type">file</span>-<span class="type">renamed</span>]</span><br></pre></td></tr></table></figure></li><li>代码提交<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line">  </span><br><span class="line"><span class="meta"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line">  </span><br><span class="line"><span class="meta"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line">  </span><br><span class="line"><span class="meta"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line">  </span><br><span class="line"><span class="meta"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line">  </span><br><span class="line"><span class="meta"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure></li><li>分支<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line"><span class="variable">$ </span>git branch</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -r</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -a</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch-name]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout -b [branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch] [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="variable">$ </span>git branch --track [branch] [remote-branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout [branch-name]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout -</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="variable">$ </span>git branch --set-upstream [branch] [remote-branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"><span class="variable">$ </span>git merge [branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="variable">$ </span>git cherry-pick [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -d [branch-name]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line"><span class="variable">$ </span>git push origin --delete [branch-name]</span><br><span class="line"><span class="variable">$ </span>git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure></li><li>标签<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> [<span class="keyword">tag</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [<span class="keyword">tag</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [<span class="keyword">tag</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">&quot;提交说明&quot;</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure></li><li>远程同步<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line"><span class="variable">$ </span>git fetch [remote]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line"><span class="variable">$ </span>git remote show [remote]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="variable">$ </span>git remote add [shortname] [url]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="variable">$ </span>git pull [remote] [branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] [branch]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --force</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --all</span><br></pre></td></tr></table></figure></li><li>撤销<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout [file]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout [commit] [file]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout .</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="variable">$ </span>git reset [file]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="variable">$ </span>git reset --hard</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="variable">$ </span>git reset [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="variable">$ </span>git reset --hard [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="variable">$ </span>git reset --keep [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="variable">$ </span>git revert [commit]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="variable">$ </span>git stash</span><br><span class="line"><span class="variable">$ </span>git stash pop</span><br></pre></td></tr></table></figure></li><li>其他<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="variable">$</span> git archive</span><br><span class="line"><span class="comment"># 忽略更新（适用于配置信息等）</span></span><br><span class="line"><span class="variable">$</span> git <span class="built_in">update-index</span> -<span class="literal">-assume</span><span class="literal">-unchanged</span> &lt;file<span class="literal">-path</span>&gt;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Git与常用的版本控制工具CVS, SVN等不同，它采用了分布式版本库的方式，不必服务器端软件支
      
    
    </summary>
    
      <category term="Git" scheme="http://yunzaifei.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yunzaifei.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>nginx简单用法和介绍</title>
    <link href="http://yunzaifei.github.io/2016/08/19/nginx%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E5%92%8C%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yunzaifei.github.io/2016/08/19/nginx简单用法和介绍/</id>
    <published>2016-08-19T09:31:46.000Z</published>
    <updated>2018-01-23T03:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同engine x） 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名，其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><p>Nginx官网：<a href="http://nginx.org/">http://nginx.org/</a>&nbsp;&nbsp;<br><a href="https://www.nginx.com/">https://www.nginx.com/</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>编译安装<br>下载对应的安装包进行编译安装<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/configure --user=www --group=www --prefix=/u</span>sr<span class="regexp">/local/</span>nginx<span class="regexp">/ --with-http_stub_status_module --with-openssl=/u</span>sr<span class="regexp">/local/</span>openssl</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li>yum安装（以centos7为例）<br>官方示例：<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">https://www.nginx.com/resources/wiki/start/topics/tutorials/install/</a><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建repo文件</span></span><br><span class="line">vi <span class="regexp">/etc/yum</span>.repos.d/nginx.repo</span><br><span class="line">  </span><br><span class="line"><span class="comment">#复制以下内容</span></span><br><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http:<span class="regexp">//</span>nginx.org<span class="regexp">/packages/</span>centos<span class="regexp">/$releasever/</span><span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#保存退出后，生成源数据缓存</span></span><br><span class="line">yum makecache</span><br><span class="line">  </span><br><span class="line"><span class="comment">#之后就可以yum命令安装</span></span><br><span class="line">yum install nginx</span><br><span class="line">  </span><br><span class="line"><span class="comment">#yum命令更新</span></span><br><span class="line">yum update nginx</span><br></pre></td></tr></table></figure></li></ul><h4 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h4><ol><li><p>proxy_pass<br>语法：proxy_pass URL;<br>配置块：location、if<br>此配置项将当前请求反向代理到URL参数指定的服务器上，URL可以是主机名或IP地址加端口的形式，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http:<span class="regexp">//</span>localhost:<span class="number">8000</span><span class="regexp">/uri/</span>;</span><br></pre></td></tr></table></figure><p>也可以是UNIX句柄：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http:<span class="regexp">//u</span>nix:<span class="regexp">/path/</span>to<span class="regexp">/backend.socket:/u</span>ri/;</span><br></pre></td></tr></table></figure><p>还可以如上节负载均衡中所示，直接使用upstream块，例如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">server &#123;</span><br><span class="line">  <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">    proxy_pass</span>  http://backend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以把HTTP转换成更安全的HTTPS，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass https:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">0.1</span>;</span><br></pre></td></tr></table></figure><p>默认情况下反向代理是不会转发请求中的Host头部的。如果需要转发，那么必须加上配置：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Host $host<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>proxy_method<br>语法：proxy_method method;<br>配置块：http、server、location<br>此配置项表示转发时的协议方法名。例如设置为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_method POST<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>那么客户端发来的GET请求在转发时方法名也会改为POST。</p></li><li><p>proxy_hide_header<br>语法：proxy_hide_header the_header;<br>配置块：http、server、location<br>Nginx会将上游服务器的响应转发给客户端，但默认不会转发以下HTTP头部字段：Date、Server、X-Pad和X-Accel-*。使用proxy_hide_header后可以任意地指定哪些HTTP头部字段不能被转发。例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_hide_header Cache-Control<span class="comment">;</span></span><br><span class="line">proxy_hide_header MicrosoftOfficeWebServer<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>proxy_pass_header<br>语法：proxy_pass_header the_header;<br>配置块：http、server、location与proxy_hide_header功能相反，proxy_pass_header会将原来禁止转发的header设置为允许转发。例如：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass_header <span class="meta">X</span>-Accel-<span class="meta">Redirect</span>;</span><br></pre></td></tr></table></figure></li><li><p>proxy_pass_request_body<br>语法：proxy_pass_request_body on | off;<br>默认：proxy_pass_request_body on;<br>配置块：http、server、location<br>作用为确定是否向上游服务器发送HTTP包体部分。</p></li><li><p>proxy_pass_request_headers<br>语法：proxy_pass_request_headers on | off;<br>默认：proxy_pass_request_headers on;<br>配置块：http、server、location<br>作用为确定是否转发HTTP头部。</p></li><li><p>proxy_redirect<br>语法：proxy_redirect [ default|off|redirect replacement ];<br>默认：proxy_redirect default;<br>配置块：http、server、location<br>当上游服务器返回的响应是重定向或刷新请求（如HTTP响应码是301或者302）时，proxy_redirect可以重设HTTP头部的location或refresh字段。<br>例如，如果上游服务器发出的响应是302重定向请求，location字段的URL是：<a href="http://localhost:8000/two/some/uri/">http://localhost:8000/two/some/uri/</a>,<br>那么在下面的配置情况下，实际转发给客户端的location是<a href="http://frontend/one/some/uri/%E3%80%82">http://frontend/one/some/uri/。</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_redirect http:<span class="regexp">//</span>localhost:<span class="number">8000</span><span class="regexp">/two/</span> http:<span class="regexp">//</span>frontend<span class="regexp">/one/</span>;</span><br></pre></td></tr></table></figure><p>这里还可以使用ngx-http-core-module提供的变量来设置新的location字段。例如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_redirect   http:<span class="regexp">//</span>localhost:<span class="number">8000</span><span class="regexp">/ http:/</span><span class="regexp">/$host:$server_port/</span>;</span><br></pre></td></tr></table></figure><p>也可以省略replacement参数中的主机名部分，这时会用虚拟主机名称来填充。例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy_redirect http:<span class="regexp">//</span>localhost:<span class="number">8000</span><span class="regexp">/two/</span> <span class="regexp">/one/</span>;</span><br></pre></td></tr></table></figure><p>使用off参数时，将使location或者refresh字段维持不变。例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure><p>使用默认的default参数时，会按照proxy_pass配置项和所属的location配置项重组发往客户端的location头部。例如，下面两种配置效果是一样的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/one/</span> &#123;  </span><br><span class="line">  proxy_pass       http:<span class="regexp">//u</span>pstream:port<span class="regexp">/two/</span>;  </span><br><span class="line">  proxy_redirect   default;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">location <span class="regexp">/one/</span> &#123;  </span><br><span class="line">  proxy_pass       http:<span class="regexp">//u</span>pstream:port<span class="regexp">/two/</span>;  </span><br><span class="line">  proxy_redirect   http:<span class="regexp">//u</span>pstream:port<span class="regexp">/two/</span>   <span class="regexp">/one/</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>proxy_next_upstream<br>语法：proxy_next_upstream [error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_404 | off ];<br>默认：proxy_next_upstream error timeout;<br>配置块：http、server、location<br>此配置项表示当向一台上游服务器转发请求出现错误时，继续换一台上游服务器处理这个请求。前面已经说过，上游服务器一旦开始发送应答，Nginx反向代理服务器会立刻把应答包转发给客户端。因此，一旦Nginx开始向客户端发送响应包，之后的过程中若出现错误也是不允许换下一台上游服务器继续处理的。这很好理解，这样才可以更好地保证客户端只收到来自一个上游服务器的应答。proxy_next_upstream的参数用来说明在哪些情况下会继续选择下一台上游服务器转发请求。<br>error：当向上游服务器发起连接、发送请求、读取响应时出错。<br>timeout：发送请求或读取响应时发生超时。<br>invalid_header：上游服务器发送的响应是不合法的。<br>http_500：上游服务器返回的HTTP响应码是500。<br>http_502：上游服务器返回的HTTP响应码是502。<br>http_503：上游服务器返回的HTTP响应码是503。<br>http_504：上游服务器返回的HTTP响应码是504。<br>http_404：上游服务器返回的HTTP响应码是404。<br>off：关闭proxy_next_upstream功能—出错就选择另一台上游服务器再次转发。</p></li><li><p>简单示例（以centos7为例）</p></li></ol><ul><li>反向代理网站<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新增配置文件</span></span><br><span class="line"><span class="attribute">vi</span> /etc/nginx/conf.d/fxdl.conf</span><br><span class="line"><span class="comment">#复制以下内容</span></span><br><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> gl.yunzaifei.com;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://www.google.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#保存退出后重启nginx</span></span><br><span class="line"><span class="attribute">nginx</span> -s reload</span><br></pre></td></tr></table></figure></li><li>反向代理北地端口<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新增配置文件</span></span><br><span class="line"><span class="attribute">vi</span> /etc/nginx/conf.d/fxdl.conf</span><br><span class="line"><span class="comment">#复制以下内容</span></span><br><span class="line">server &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> api.xxx.com;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $http_host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8000/;</span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存退出后重启nginx</span></span><br><span class="line"><span class="attribute">nginx</span> -s reload</span><br></pre></td></tr></table></figure>Nginx的反向代理模块还提供了很多种配置，如设置连接的超时时间、临时文件如何存储，以及最重要的如何缓存上游服务器响应等功能。这些配置可以通过阅读ngx_http_proxy_module模块的说明了解，只有深入地理解，才能实现一个高性能的反向代理服务器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx（发音同engine x） 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以
      
    
    </summary>
    
      <category term="Nginx" scheme="http://yunzaifei.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yunzaifei.github.io/tags/Nginx/"/>
    
  </entry>
  
</feed>
