[{"title":"Docker常用命令","date":"2024-01-03T08:09:59.000Z","path":"2024/01/03/Docker常用命令/","text":"服务 12# 查看Docker版本信息docker version 镜像 123456789101112131415161718# 列出镜像docker images 或者 docker image ls# 删除指定镜像docker rmi &lt;镜像Id&gt; 或者 docker image rm &lt;镜像Id&gt;# 删除所有镜像docker rmi $(docker images -q)# 删除所有&lt;none&gt;镜像docker rmi $(docker images | grep &quot;none&quot; | awk &#x27;&#123;print $3&#125;&#x27;)# 导入镜像docker load# 构建镜像docker build docker build -t [镜像自定义名称] .# 运行镜像docker run [镜像ID] docker run -it --name [容器自定义名称] -d [镜像名称]:latest# 保存镜像到本地docker save [镜像名称] | gzip &gt; [保存文件名称]# 加载本地镜像docker load &lt; [保存镜像文件名称] 容器 123456789101112131415161718192021222324# 列出本机运行的容器docker ps# 列出本机所有的容器（包括停止和运行）docker ps -a# 新建并启动docker run [镜像名/镜像ID]# 启动已终止容器docker start [容器ID]# 停止运行的容器docker stop [容器ID]# 杀死容器进程docker kill [容器ID]# 重启容器docker restart [容器ID]# 删除容器docker rm [容器ID]# 交互式进入容器docker exec [容器ID]# 导出容器docker export [容器ID]# 导入容器docker import [路径]# 查看日志docker logs [容器ID]","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yunzaifei.github.io/tags/Docker/"}]},{"title":"服务器设置和Docker安装","date":"2024-01-03T08:06:37.000Z","path":"2024/01/03/服务器设置和Docker安装/","text":"服务器厂商每年都会搞促销活动，但是促销只针对新买的服务器，而之前买的服务器续费就没有促销。这样就导致，旧的服务器到期了就不能用了，上面部署的服务都要迁移到新的服务器。 服务器设置服务器选Debian 更改root密码 1passwd 新建用户 1useradd -m zyf 配置免密登录 1234567891011# 本地生成公钥、私钥ssh-keygen -t ed25519 -f xxx_ed25519# 在目标服务器操作, 复制生成的公钥vi /home/zyf/.ssh/authorized_keyschown -R zyf:zyf /home/zyf/.sshchmod 700 /home/zyf/.sshchmod 600 /home/zyf/.ssh/authorized_keys 禁用密码登录和root登录 1234567vi /etc/ssh/sshd_config# 禁止root登录 PermitRootLogin yes改成no# 禁止密码登录 PasswordAuthentication yes改为no# 启用密钥验证 RSAAuthentication yes# 重启sshd服务systemctl restart sshd Docker 安装 注册源 12345678910111213# Add Docker&#x27;s official GPG key:sudo apt-get updatesudo apt-get install ca-certificates curl gnupgsudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg# Add the repository to Apt sources:echo \\ &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\ $(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt-get update 安装 1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yunzaifei.github.io/tags/Docker/"}]},{"title":"gitea的docker安装","date":"2023-06-02T06:35:54.000Z","path":"2023/06/02/gitea的docker安装/","text":"Gitea是一个自己托管的 Git 服务程序。他和GitHub, Bitbucket或Gitlab等比较类似。他是从Gogs 发展而来，Gitea的首要目标是创建一个极易安装，运行非常快速，安装和使用体验良好的自建 Git 服务。 官网：https://gitea.io/zh-cn/ 安装 docker-composeGitea在其Docker Hub组织内提供自动更新的Docker镜像。可以始终使用最新的稳定标签或使用其他服务来更新Docker镜像。 更新 apt 包索引并安装包以允许 apt 通过 HTTPS 使用存储库： 12sudo apt-get updatesudo apt-get install ca-certificates curl gnupg 添加Docker的官方GPG密钥： 123sudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpgsudo chmod a+r /etc/apt/keyrings/docker.gpg 使用以下命令设置软件源： 1234echo \\ &quot;deb [arch=&quot;$(dpkg --print-architecture)&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\ &quot;$(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;)&quot; stable&quot; | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 更新 apt 包索引： 1sudo apt-get update 安装Docker Engine、containerd和Docker Compose: 1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 基本安装最简单的设置只是创建一个卷和一个网络，然后将gitea/gitea:latest镜像作为服务启动。创建一个类似gitea的目录，并将以下内容粘贴到名为docker-compose.yml的文件中。请注意，该卷应由配置文件中指定的UID/GID的用户&#x2F;组拥有。如果您不授予卷正确的权限，则容器可能无法启动。另请注意，标签 :latest 将安装当前的开发版本。对于稳定的发行版，您可以使用 :1 或指定某个发行版，例如 1.19.0-rc1。 1234567891011121314151617181920212223version: &quot;3&quot;networks: gitea: external: falseservices: server: image: gitea/gitea:1.19.0-rc1 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;3000:3000&quot; - &quot;222:22&quot; MySQL 数据库要将Gitea与MySQL数据库结合使用，请将这些更改应用于上面创建的docker-compose.yml文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243version: &quot;3&quot;networks: gitea: external: falseservices: server: image: gitea/gitea:1.19.0-rc1 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000+ - GITEA__database__DB_TYPE=mysql+ - GITEA__database__HOST=db:3306+ - GITEA__database__NAME=gitea+ - GITEA__database__USER=gitea+ - GITEA__database__PASSWD=gitea restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;3000:3000&quot; - &quot;222:22&quot;+ depends_on:+ - db++ db:+ image: mysql:8+ restart: always+ environment:+ - MYSQL_ROOT_PASSWORD=gitea+ - MYSQL_USER=gitea+ - MYSQL_PASSWORD=gitea+ - MYSQL_DATABASE=gitea+ networks:+ - gitea+ volumes:+ - ./mysql:/var/lib/mysql 命名卷要使用命名卷而不是主机卷，请在docker-compose.yml配置中定义并使用命名卷。此更改将自动创建所需的卷。您无需担心命名卷的权限；Docker将自动处理该问题。 12345678910111213141516171819202122232425version: &quot;3&quot;networks: gitea: external: false+volumes:+ gitea:+ driver: local+services: server: image: gitea/gitea:1.19.0-rc1 container_name: gitea restart: always networks: - gitea volumes:- - ./gitea:/data+ - gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - &quot;3000:3000&quot; - &quot;222:22&quot; 启动要基于docker-compose启动此设置，请执行docker-compose up -d，以在后台启动Gitea。使用docker-compose ps将显示 Gitea 是否正确启动。可以使用docker-compose logs查看日志。 要关闭设置，请执行docker-compose down。这将停止并杀死容器。这些卷将仍然存在。 注意：如果在 http 上使用非 3000 端口，请更改app.ini以匹配LOCAL_ROOT_URL = http://localhost:3000/。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yunzaifei.github.io/tags/Docker/"},{"name":"Git","slug":"Git","permalink":"http://yunzaifei.github.io/tags/Git/"},{"name":"gitea","slug":"gitea","permalink":"http://yunzaifei.github.io/tags/gitea/"}]},{"title":"Nodejs项目配置Typescript,Eslint,prettier等","date":"2022-12-27T06:21:02.000Z","path":"2022/12/27/Nodejs项目配置Typescript-Eslint-prettier等/","text":"前言现代化的工程项目搭建，已经不仅仅满足于可以用了，更多要求规范使用。为实现这已目的，项目搭建离不开Typescript、Eslint、prettier的配置。 Nodejs项目搭建执行npm init -y命令生产package.json文件 Typescript 安装typescript执行命令 npm install typescript --save-dev 安装@types/node执行命令 npm install @types/node --save-dev 生成tsconfig.json文件执行命令 npx tsc --init，常见配置见tsconfig配置1234567891011&#123; &quot;compilerOptions&quot;: &#123; ... &quot;rootDir&quot;: &quot;./src&quot;, // 读取ts文件根目录 &quot;outDir&quot;: &quot;./dist&quot;, // 生成js文件路径 &quot;removeComments&quot;: true, // 生成js文件时移除注释 ... &#125; &quot;include&quot;: [&quot;src&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;]&#125; 安装ts-node执行命令 npm install ts-node --save-dev, ts-node可以运行时解析ts文件，无需转换成js运行。 配置nodemon新建nodemon.json文件123456&#123; &quot;watch&quot;: [&quot;src&quot;], &quot;ext&quot;: &quot;.ts,.js&quot;, &quot;ignore&quot;: [], &quot;exec&quot;: &quot;ts-node ./src/index.ts&quot;&#125; package.json中配置scripts命令12345&quot;build&quot;: &quot;tsc&quot;,&quot;prestart&quot;: &quot;npm run build&quot;,&quot;start&quot;: &quot;node ./dist/index.js&quot;,&quot;start:dev&quot;: &quot;nodemon&quot;,&quot;lint&quot;: &quot;eslint . --ext .js,.ts&quot; Eslint 初始化Eslint执行命令 npx eslint --init，然后根据自己需求选择配置 配置.eslintrc.js文件.eslintrc.js文件是配置文件，如果某些想忽略，可以新建文件.eslintignor，写入想要忽略的文件路径 prettier 安装依赖执行命令npm install eslint-config-prettier eslint-plugin-prettier --save-dev安装 eslint-config-prettier、eslint-plugin-prettier即可 修改.eslintrc.js文件1234567extends: [..., &#x27;plugin:prettier/recommended&#x27;],overrides: [],parserOptions: &#123; ecmaVersion: &#x27;latest&#x27;, sourceType: &#x27;module&#x27;, project: &#x27;./tsconfig.json&#x27;,&#125;, 常见prettier配置123456789101112131415161718192021222324252627282930313233module.exports = &#123; // 1.一行代码的最大字符数，默认是80(printWidth: &lt;int&gt;) printWidth: 80, // 2.tab宽度为2空格(tabWidth: &lt;int&gt;) tabWidth: 2, // 3.是否使用tab来缩进，我们使用空格(useTabs: &lt;bool&gt;) useTabs: false, // 4.结尾是否添加分号，false的情况下只会在一些导致ASI错误的其工况下在开头加分号，我选择无分号结尾的风格(semi: &lt;bool&gt;) semi: false, // 5.使用单引号(singleQuote: &lt;bool&gt;) singleQuote: true, // 6.object对象中key值是否加引号（quoteProps: &quot;&lt;as-needed|consistent|preserve&gt;&quot;）as-needed只有在需求要的情况下加引号，consistent是有一个需要引号就统一加，preserve是保留用户输入的引号 quoteProps: &#x27;as-needed&#x27;, // 7.在jsx文件中的引号需要单独设置（jsxSingleQuote: &lt;bool&gt;） jsxSingleQuote: false, // 8.尾部逗号设置，es5是尾部逗号兼容es5，none就是没有尾部逗号，all是指所有可能的情况，需要node8和es2017以上的环境。（trailingComma: &quot;&lt;es5|none|all&gt;&quot;） trailingComma: &#x27;es5&#x27;, // 9.object对象里面的key和value值和括号间的空格(bracketSpacing: &lt;bool&gt;) bracketSpacing: true, // 10.jsx标签多行属性写法时，尖括号是否另起一行(jsxBracketSameLine: &lt;bool&gt;) jsxBracketSameLine: false, // 11.箭头函数单个参数的情况是否省略括号，默认always是总是带括号（arrowParens: &quot;&lt;always|avoid&gt;&quot;） arrowParens: &#x27;always&#x27;, // 12.range是format执行的范围，可以选执行一个文件的一部分，默认的设置是整个文件（rangeStart: &lt;int&gt; rangeEnd: &lt;int&gt;） rangeStart: 0, rangeEnd: Infinity, // 18. vue script和style标签中是否缩进,开启可能会破坏编辑器的代码折叠 vueIndentScriptAndStyle: false, // 19. endOfLine: &quot;&lt;lf|crlf|cr|auto&gt;&quot; 行尾换行符,默认是lf, endOfLine: &#x27;lf&#x27;, // 20.embeddedLanguageFormatting: &quot;off&quot;,默认是auto,控制被引号包裹的代码是否进行格式化 embeddedLanguageFormatting: &#x27;off&#x27;,&#125; 文档资料 Typescript Eslint Prettier nodemon","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yunzaifei.github.io/tags/nodejs/"},{"name":"typescript","slug":"typescript","permalink":"http://yunzaifei.github.io/tags/typescript/"},{"name":"eslint","slug":"eslint","permalink":"http://yunzaifei.github.io/tags/eslint/"},{"name":"prettier","slug":"prettier","permalink":"http://yunzaifei.github.io/tags/prettier/"}]},{"title":"Docker入门","date":"2022-05-05T03:48:36.000Z","path":"2022/05/05/Docker入门/","text":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。 官网文档：https://docs.docker.com/官方仓库：https://hub.docker.com/ Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。 Dcoker基本概念Docker 包括三个基本概念： 镜像（Image）：Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库（Repository）类似Git的远程仓库，集中存放镜像文件。 Docker常用命令","tags":[{"name":"Docker","slug":"Docker","permalink":"http://yunzaifei.github.io/tags/Docker/"}]},{"title":"GraphQL 入门","date":"2020-06-14T00:46:38.000Z","path":"2020/06/14/GraphQL入门/","text":"GraphQLGraphQL既是一种用于API的查询语言也是一个满足你数据查询的运行时。 GraphQL对你的API中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。 GraphQL官网：https://graphql.org GraphQL中文文档：https://graphql.cn Apollo GraphQL：https://www.apollographql.com/docs 入门GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。 一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是 me，这个用户的名称可能像这样： 12345678type Query &#123; me: User&#125;type User &#123; id: ID name: String&#125; 一并的还有每个类型上字段的解析函数： 1234567function Query_me(request) &#123; return request.auth.user;&#125;function User_name(user) &#123; return user.getName();&#125; 一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。例如这个查询： 12345&#123; me &#123; name &#125;&#125; 会产生这样的JSON结果： 12345&#123; &quot;me&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot; &#125;&#125;","tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"http://yunzaifei.github.io/tags/GraphQL/"}]},{"title":"Redux简介","date":"2019-10-31T02:07:24.000Z","path":"2019/10/31/Redux简介/","text":"ReduxRedux 是 JavaScript 状态容器，提供可预测化的状态管理。 Redux官网：https://redux.js.org/ Redux中文文档：https://cn.redux.js.org/ react-redux官网：https://react-redux.js.org/ Redux视频：https://egghead.io/courses/getting-started-with-redux Provide全局引入react-redux 123456789101112131415import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;import store from &#x27;./store&#x27;import App from &#x27;./App&#x27;const rootElement = document.getElementById(&#x27;root&#x27;)ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, rootElement) connect组件中使用react-redux 1234567891011121314151617import &#123; connect &#125; from &#x27;react-redux&#x27;import &#123; increment, decrement, reset &#125; from &#x27;./actionCreators&#x27;// const Counter = ...const mapStateToProps = (state /*, ownProps*/) =&gt; &#123; return &#123; counter: state.counter &#125;&#125;const mapDispatchToProps = &#123; increment, decrement, reset &#125;export default connect( mapStateToProps, mapDispatchToProps)(Counter) redux-thunkredux-thunk就是redux的中间件，中间件就是你可以在收到请求和返回请求之间做一些操作。 github地址：https://github.com/reduxjs/redux-thunk 用法，在store.js文件中： 1234567891011121314import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;;import &#123; composeWithDevTools &#125; from &#x27;redux-devtools-extension&#x27;;import thunkMiddleware from &#x27;redux-thunk&#x27;;import reducer from &#x27;./reducers&#x27;;const initializeStore = (initialState = &#123;&#125;) =&gt; createStore( reducer, initialState, process.env.NODE_ENV === &#x27;production&#x27; ? applyMiddleware(thunkMiddleware) : composeWithDevTools(applyMiddleware(thunkMiddleware)),);export default initializeStore; redux-thunk最重要的思想，就是可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。 1234567891011export function addCount() &#123; return &#123;type: ADD_COUNT&#125;&#125;export function addCountAsync() &#123; return dispatch =&gt; &#123; setTimeout( () =&gt; &#123; dispatch(addCount()) &#125;,2000) &#125;&#125; HooksuseSelector基本用法： 1234567import React from &#x27;react&#x27;import &#123; useSelector &#125; from &#x27;react-redux&#x27;export const CounterComponent = () =&gt; &#123; const counter = useSelector(state =&gt; state.counter) return &lt;div&gt;&#123;counter&#125;&lt;/div&gt;&#125; useDispatch基本用法： 123456789101112131415import React from &#x27;react&#x27;import &#123; useDispatch &#125; from &#x27;react-redux&#x27;export const CounterComponent = (&#123; value &#125;) =&gt; &#123; const dispatch = useDispatch() return ( &lt;div&gt; &lt;span&gt;&#123;value&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;increment-counter&#x27; &#125;)&#125;&gt; Increment counter &lt;/button&gt; &lt;/div&gt; )&#125;","tags":[{"name":"Redux","slug":"Redux","permalink":"http://yunzaifei.github.io/tags/Redux/"}]},{"title":"Nextjs简介","date":"2019-09-21T08:45:02.000Z","path":"2019/09/21/Nextjs简介/","text":"Nextjsnext.js是一个非常棒的轻量级的react同构框架，使用它可以快速的开发出基于服务端渲染的react应用。 Nextjs官网：https://nextjs.org/ Nextjs官方demo：https://github.com/zeit/next.js/tree/canary/examples Nextjs中文文档：https://nextjs.frontendx.cn/ 路由处理官方文档：https://nextjs.org/docs#routing 页面中直接跳转用法： 1234567891011121314151617181920import Link from &#x27;next/link&#x27;function Home() &#123; return ( &lt;&gt; &lt;ul&gt; &lt;li&gt;Home&lt;/li&gt; &lt;li&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Us&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;This is our homepage.&lt;/h1&gt; &lt;/&gt; )&#125;export default Home js方法中跳转： 1234567891011import Router from &#x27;next/router&#x27;function ReadMore() &#123; return ( &lt;div&gt; Click &lt;span onClick=&#123;() =&gt; Router.push(&#x27;/about&#x27;)&#125;&gt;here&lt;/span&gt; to read more &lt;/div&gt; )&#125;export default ReadMore Dynamic Import官方文档：https://nextjs.org/docs#dynamic-import 因为Nextjs代码跑起来会走两套环境，分别是客户端和服务端环境，客户端环境和常规react开发一样，服务端环境就比较麻烦，window，localStorage，navigator.userAgent这些就会在服务端报undefined错误。所以需要控制好代码有哪些是在两个环境通用，哪些只能在客户端环境运行。 比较常见的就是视频播放，视频播放器即不需要也没办法在服务端渲染，那么如何控制它只在客户端渲染？Nextjs提供了Dynamic Import方法来处理该问题。 123456789101112131415161718import dynamic from &#x27;next/dynamic&#x27;const DynamicComponentWithNoSSR = dynamic( () =&gt; import(&#x27;../components/hello3&#x27;), &#123; ssr: false &#125;)function Home() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;DynamicComponentWithNoSSR /&gt; &lt;p&gt;HOME PAGE is here!&lt;/p&gt; &lt;/div&gt; )&#125;export default Home 自定义配置官方文档：https://nextjs.org/docs#custom-configuration","tags":[{"name":"Nextjs","slug":"Nextjs","permalink":"http://yunzaifei.github.io/tags/Nextjs/"}]},{"title":"Callback,Promise和Async/Await","date":"2019-08-15T03:48:18.000Z","path":"2019/08/15/Callback-Promise和Async-Await/","text":"JavaScript是单线程语言，但是js中有很多任务耗时比较长，比如ajax请求，如果都按照顺序进行，往往会出现浏览器无响应的情况，所以就需要异步的形式。JS中所有的任务可以分为两种：同步任务和异步任务。 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 异步任务：不进入主线程，而进入任务队列中的任务，只有任务队列通知主线程，某个异步任务可以执行了，这个任务才会进入主线程执行。 事件循环（Event Loop）：只有执行栈中的所有同步任务都执行完毕，系统才会读取任务队列，看看里面的异步任务哪些可以执行，然后那些对应的异步任务，结束等待状态，进入执行栈，开始执行。 CallBack回调函数本身是我们约定俗成的一种叫法，我们定义它，但是并不会立即执行它，它最终在其他地方执行了。 优点：比较容易理解； 缺点：1.高耦合，维护困难，回调地狱; 2.每个任务只能指定一个回调函数; 3.如果几个异步操作之间并没有顺序之分，同样也要等待上一个操作执行结束再进行下一个操作。 回调地狱： Promisepromise对象的构造函数语法为： 123let promise = new Promise(function(resolve, reject) &#123; // executor (the producing code, &quot;singer&quot;)&#125;); 它的参数resolve和reject是JavaScript本身提供的回调。我们的代码仅在执行程序内部。当代码执行完后，它应用调用以下回调之一： resolve(value)—如果成功完成，结果为value。 reject(error)—如果发生错误，error则是错误对象。 Promise.then .catch .finallyPromise.then相当于执行callback，不过比起callback的嵌套模式，Promise.then().then().then()...的链式写法看起来更直观和美观。 catch，finally的用法相当于try...catch...finally Async/Await假如，一个页面中的很多方法都依赖于一个异步函数值的结果，又不想把写好的许多方法放到Promise.the中处理，这个时候你急切得需要一个把异步函数转换成同步函数处理的方式，这个时候async/await方法应运而生。 123456789let promise = new Promise(function(resolve, reject) &#123; // executor (the producing code, &quot;singer&quot;)&#125;);promise.then(res =&gt; &#123; const &#123; data &#125; = res; ....&#125;).catch(err =&gt; &#123; console.log(errr);&#125;) 等价于 12345678910async function do() &#123; try &#123; const res = await promise(); const &#123; data &#125; = res; ... &#125; catch(err)&#123; console.log(errr); &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yunzaifei.github.io/tags/javascript/"}]},{"title":"PWA实战（4）—Notification","date":"2018-09-12T09:21:43.000Z","path":"2018/09/12/PWA实战（4）—Notification/","text":"推送通知 ( Push Notification )或者也可以称作推播，有智慧手机的人我想应该非常熟悉，尤其是App盛行的时期几乎每只App都会有推送通知功能，这也是恶梦的开始，你会发觉在大半夜里你的手机会三不五时地叫你起床，所以现在的手机几乎都内建了勿扰模式，让使用者可以设定每天的某个时段可以封锁特定的讯息通知，甚至现在的系统都可以让使用用决定App允许那些权限。 推送通知就像一把双刃剑，懂得善用它可以提升用户体验，反之，若滥用它则会让使用者观感不好。 体验pwa推送这个网站可以让你体验一下pwa推送，可以在pc和手机上分别体验。链接：https://web-push-book.gauntface.com/demos/notification-examples/ 推送通知条款 通知 - 在应用程序的普通用户界面（即浏览器）之外向用户显示的消息 推送消息 - 从服务器发送到客户端的消息 推送通知 - 响应推送消息而创建的通知 通知API - 用于配置和向用户显示通知的界面 Push API - 用于将应用程序订阅到推送服务并在服务工作者中接收推送消息的接口 Web Push - 一个非正式术语，指的是将消息从服​​务器推送到Web上的客户端过程中涉及的过程或组件 推送服务 - 用于将推送消息从服务器路由到客户端的系统。每个浏览器都实现自己的推送服务。 Web推送协议 - 描述应用程序服务器或用户代理如何与推送服务交互 实战操作参考链接：https://developers.google.com/web/fundamentals/codelabs/push-notifications/?hl=zh-cn 练习源码： 1git clone https://github.com/GoogleChrome/push-notifications.git 模拟推送服务器：https://web-push-codelab.glitch.me/ 推送服务实际应用中，需要搭建推送服务负责想客户端推送消息网络推送库：https://github.com/web-push-libs/nodejs使用的web-push库：https://www.npmjs.com/package/web-push 关于墙的问题推送服务的流程类似于，自己搭建的推送服务发送通知到浏览器厂商搭建的推送服务，浏览器厂商搭建的推送服务识别后发送到对应的浏览器客户端。这个过程依赖浏览器厂商搭建的推送服务。目前对pwa推送规范支持最好的有chrom浏览器和firefox浏览器，因为墙的原因，chrome浏览器的推送服务无法送达，但firefox没有任何问题。所以想使用pwa推送的话，建议用户使用firefox浏览器就可以了。","tags":[{"name":"PWA","slug":"PWA","permalink":"http://yunzaifei.github.io/tags/PWA/"}]},{"title":"PWA实战（3）—Manifest","date":"2018-08-23T02:03:46.000Z","path":"2018/08/23/PWA实战（3）—Manifest/","text":"Manifest是一个 JSON 文件，您（即开发者）可以利用它控制在用户想要看到应用的区域（例如移动设备主屏幕）中如何向用户显示网络应用或网站，指示用户可以启动哪些功能，以及定义其在启动时的外观。 Manifest提供了将网站书签保存到设备主屏幕的功能。当网站以这种方式启动时： 它具有唯一的图标和名称，以便用户将其与其他网站区分开来。 它会在下载资源或从缓存恢复资源时向用户显示某些信息。 它会向浏览器提供默认显示特性，以避免网站资源可用时的过渡过于生硬。 它通过一个文本文件中的元数据这一简单机制完成所有这些工作。实现： 创建清单并将其链接到您的页面，这是非常简单的过程。 控制用户从主屏幕启动时看到的内容。 这包括启动画面、主题颜色以及打开的网址等。 创建清单在对网络应用清单做详细探究之前，让我们先创建一个基本清单，然后为其链接一个网页。 不管您要什么，都可以调用清单。大多数人使用manifest.json。下面是一个示例： 12345678910111213141516171819202122&#123; &quot;short_name&quot;: &quot;AirHorner&quot;, &quot;name&quot;: &quot;Kinlan&#x27;s AirHorner of Infamy&quot;, &quot;icons&quot;: [ &#123; &quot;src&quot;: &quot;launcher-icon-1x.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;48x48&quot; &#125;, &#123; &quot;src&quot;: &quot;launcher-icon-2x.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;96x96&quot; &#125;, &#123; &quot;src&quot;: &quot;launcher-icon-4x.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;192x192&quot; &#125; ], &quot;start_url&quot;: &quot;index.html?launcher=true&quot;&#125; 确保包括以下内容： 在用户主屏幕上用作文本的short_name。 在网络应用安装横幅中使用的name。 将清单的相关信息告知浏览器在您创建清单且将清单添加到您的网站之后，将link标记添加到包含网络应用的所有页面上，如下所示： 1&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; 设置启动网址如果您不提供start_url，则将使用当前页面，这不太可能是您的用户想要的内容。 但这并不是将它包括在内的唯一原因。 由于您现在可以定义应用的启动方式，因此可向start_url添加一个查询字符串参数来说明其启动方式。 1&quot;start_url&quot;: &quot;/?utm_source=homescreen&quot; 这可以是您希望的任何内容；我们要使用的值的优点是对网站统计十分有意义。 自定义图标当用户将您的网站添加到其主屏幕时，您可以定义一组供浏览器使用的图标。您可以通过类型和大小定义它们，如下所示： 1234567891011121314151617&quot;icons&quot;: [&#123; &quot;src&quot;: &quot;images/touch/icon-128x128.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;128x128&quot; &#125;, &#123; &quot;src&quot;: &quot;images/touch/apple-touch-icon.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;152x152&quot; &#125;, &#123; &quot;src&quot;: &quot;images/touch/ms-touch-icon-144x144-precomposed.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;144x144&quot; &#125;, &#123; &quot;src&quot;: &quot;images/touch/chrome-touch-icon-192x192.png&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;sizes&quot;: &quot;192x192&quot; &#125;], 添加启动画面当您从主屏幕启动网络应用时，幕后执行了若干操作： Chrome 启动。 显示页面的渲染器启动。 您的网站从网络（如果网站有服务工作线程，则从缓存）加载。 执行以上操作时，屏幕显示为白色并且看似已经停滞。如果您从网络加载网页时页面需要花费不止一两秒的时间才能让首页显现任何内容，这种情况将变得尤为明显。 为提供更优质的用户体验，您可以用标题、颜色和图像来替换白色屏幕。 设置图像和标题如果您从未落下课程进度，您已应完成了图像和标题的设置。Chrome 会根据清单的特定成员推断图像和标题。此处的要点是了解详情。 启动画面图像提取自icons数组。Chrome 为设备选择最接近 128dp 的图像。标题是直接从name成员获取的。 设置背景颜色利用适当命名的background_color属性指定背景颜色。 Chrome 在网络应用启动后会立即使用此颜色，这一颜色将保留在屏幕上，直至网络应用首次呈现为止。 要设置背景颜色，请在您的清单中设置下列内容： 1&quot;background_color&quot;: &quot;#2196F3&quot;, 现在，从主屏幕启动您的网站时将不会呈现白色屏幕。 该属性的建议适用值是加载页面的背景颜色。使用与加载页面相同的颜色可实现从启动画面到首页的平稳过渡。 设置主题颜色使用theme_color属性指定主题颜色。该属性设置工具栏的颜色。 对此，我们还建议复制某种现有颜色，具体地讲就是theme-color &lt;meta&gt;。 设置启动样式利用网络应用清单来控制显示类型和页面方向。 自定义显示类型您可以通过将display类型设置为standalone，让您的网络应用隐藏浏览器的UI： 1&quot;display&quot;: &quot;standalone&quot; 如果您认为用户喜欢在浏览器中像正常网站一样查看您的网页，您可以将display类型设置为browser： 1&quot;display&quot;: &quot;browser&quot; 指定页面的初始方向您可以强制一个特定方向，这对于某些应用很有用，例如只能在一个方向上运行的游戏。 请有选择地使用。 用户更愿意能够自行选择方向。 1&quot;orientation&quot;: &quot;landscape&quot; 提供全站主题颜色Chrome 在 2014 年为您的网站引入了主题颜色这一概念。主题颜色是来自您的网页的提示，用于告知浏览器使用什么颜色来为地址栏等 UI 元素着色。 如果没有清单，您需要在每个页面上定义主题颜色，并且如果您拥有的是大型网站或旧版网站，进行大量全站更改并不可行。向您的清单添加theme_color属性后，从主屏幕启动网站时，网域中的每个页面都将自动获得主题颜色。 1&quot;theme_color&quot;: &quot;#2196F3&quot;","tags":[{"name":"PWA","slug":"PWA","permalink":"http://yunzaifei.github.io/tags/PWA/"}]},{"title":"PWA实战（2）—Service Wroker","date":"2018-08-12T13:00:46.000Z","path":"2018/08/12/PWA实战（2）—Service-Wroker/","text":"什么是Service Worker一个Service Worker是一种类型的web worker。它本质上是一个JavaScript文件，它与主浏览器线程分开运行，拦截网络请求，缓存或从缓存中检索资源，以及传递推送消息。 由于工作者与主线程分开运行，因此Service Worker独立于与其关联的应用程序。这有几个后果： 因为Service Worker没有阻塞（它被设计为完全异步）同步XHR并且localStorage不能在Service Worker中使用。 当应用程序未处于活动状态时，Service Worker可以从服务器接收推送消息。这样，即使未在浏览器中打开，您的应用也会向用户显示推送通知。 Service Worker无法直接访问DOM。为了与页面通信，Service Worker使用postMessage()方法发送数据，并使用message事件监听器来接收数据。 关于Service Worker的注意事项： Service Worker是一种可编程网络代理，可让您控制如何处理来自页面的网络请求。 Service Worker只能通过HTTPS运行。由于Service Worker可以拦截网络请求并修改响应，因此“中间人”攻击可能非常糟糕。 注意：像Let&#39;s Encrypt这样的服务允许您免费获得SSL证书以便在服务器上安装。 Service Worker工作程序在不使用时变为空闲状态，并在下次需要时重新启动。您不能依赖事件之间持久存在的全局状态。如果存在需要在重新启动时保留和重用的信息，则可以使用IndexedDB数据库。 Service Worker广泛使用Promises。 Service Worker能做什么Service Worker使应用程序能够控制网络请求，缓存这些请求以提高性能，并提供对缓存内容的脱机访问。 Service Worker依赖于两个API来使应用程序脱机工作： Fetch（从网络检索内容的标准方法）和Cache（应用程序数据的持久内容存储）。这个Cache是持久的，独立于浏览器缓存或网络状态。 提高应用程序/站点的性能缓存资源将使内容在大多数网络条件下加载更快。有关缓存策略的完整列表，请参阅 使用Caching files with the service worker和The Offline Cookbook。 让您的应用“离线优先”使用Service Worker内部的Fetch API，我们可以拦截网络请求，然后使用所请求资源以外的内容修改响应。当用户离线时，我们可以使用此技术从缓存中提供资源。请参阅 使用Service Worker缓存文件以获得此技术的实际操作经验。 充当高级功能的基础Service Worker提供了使Web应用程序像本机应用程序一样工作的功能的起点。其中一些功能是： Notifications API：使用操作系统的本机通知系统显示通知并与通信交互的方法。 Push API：一种API，可让您的应用订阅推送服务并接收推送消息。推送消息被传递给Service Worker，Service Worker可以使用消息中的信息来更新本地状态或向用户显示通知。由于Service Worker独立于主应用程序运行，因此即使浏览器未运行，他们也可以接收和显示通知。 Background Sync API：允许您将操作推迟到用户具有稳定连接。这对于确保实际发送用户想要发送的内容非常有用。此API还允许服务器定期更新应用程序，以便应用程序可以在下次联机时进行更新 Channel Messaging API：允许Web工作者和Service Worker相互通信并与主机应用程序通信。此API的示例包括新内容通知和需要用户交互的更新。 Service Worker生命周期Service Worker在其生命周期中经历三个步骤： 注册 安装 激活 注册和作用域要安装Service Worker，您需要在主JavaScript代码中注册它。注册会告诉浏览器您的Service Worker所在的位置，并开始在后台安装它。我们来看一个例子： 123456789if (&#x27;serviceWorker&#x27; in navigator) &#123; navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;) .then(function(registration) &#123; console.log(&#x27;Registration successful, scope is:&#x27;, registration.scope); &#125;) .catch(function(error) &#123; console.log(&#x27;Service worker registration failed, error:&#x27;, error); &#125;);&#125; 此代码首先检查浏览器支持navigator.serviceWorker。然后向Service Worker注册，navigator.serviceWorker.register返回在Service Worker成功注册时解析的promise，然后用记录registration.scope。 scope是确定哪些Service Worker控制的，换句话说，从该路径的Service Worker将拦截请求。默认范围是Service Worker文件的位置，并扩展到下面的所有目录。因此，如果service-worker.js位于根目录中，则Service Worker将控制来自此域的所有文件的请求。 您还可以通过在注册时传入其他参数来设置任意范围。例如： 123navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123; scope: &#x27;/app/&#x27;&#125;); 在这种情况下，我们设置Service Worker的作用域到/app/，这意味着Service Worker作用域包括/app/，/app/lower/以及/app/lower/lower等，但不包括/app或者/，以及其他上一级的路径。 如果已安装Service Worker，则navigator.serviceWorker.register返回当前Service Worker的注册对象。 安装一旦浏览器注册了Service Worker，就可以尝试安装。如果浏览器认为Service Worker是新用户，则会安装Service Worker，原因是该站点当前没有已注册的Service Worker，或者因为新Service Worker与之前安装的Service Worker之间存在字节差异。 Service Worker安装会在安装过程中触发事件。我们可以在Service Worker安装过程中包含一个事件监听器，以便在安装Service Worker时执行某些任务。例如，在安装过程中，Service Worker可以预先缓存Web应用程序的某些部分，以便在用户下次打开它时立即加载。因此，在第一次加载之后，您将从即时重复加载中受益，并且在这些情况下，您的交互时间将变得更好。安装事件侦听器的示例如下所示： 1234// Listen for install event, set callbackself.addEventListener(&#x27;install&#x27;, function(event) &#123; // Perform some task&#125;); 激活一旦Service Worker成功安装，它就会转换到激活阶段。如果存在由前一个Service Worker控制的任何打开页面，则新Service Worker进入waiting状态。新Service Worker仅在不再加载仍在使用旧Service Worker的任何页面时激活。这可确保在任何给定时间只运行一个版本的Service Worker。 注意：仅刷新页面不足以将控制权转移给新的Service Worker，因为在卸载当前页面之前将请求新页面，并且不会有旧Service Worker未使用的时间。当新Service Worker激活时，将激活的Service Worker中触发事件activate。此事件侦听器是清理过时缓存的好地方 123self.addEventListener(&#x27;activate&#x27;, function(event) &#123; // Perform some task&#125;); 激活后，Service Worker将控制在其作用域内加载的所有页面，并开始侦听来自这些页面的事件。但是，在Service Worker激活之前加载的页面不在Service Worker控制之下。新Service Worker只会在您关闭并重新打开应用程序或执行 clients.claim()时接管。在此之前，新Service Worker不会截获此页面的请求。这是有意识的，以确保您的网站的一致性。","tags":[{"name":"PWA","slug":"PWA","permalink":"http://yunzaifei.github.io/tags/PWA/"}]},{"title":"PWA实战（1）—概述","date":"2018-07-02T02:53:57.000Z","path":"2018/07/02/PWA实战（1）—概述/","text":"什么是PWAPWA（Progressive Web Apps）是渐进式web应用程序，它是2016年，Google I/O 大会上提出的一个概念。这并不是描述一个技术，而是一些技术的合集。PWA是专门应对手机Web开发而提出的，通过新技术的成熟，实现最好的Web + 手机APP。 PWA特点 可发现：能被识别为应用程序，通过搜索引擎能容易找到。 可安装：可用于的移动设备，用户的主屏幕上 - 没有应用程序商店的麻烦。 可连接：通过URL轻松共享，无需复杂的安装。 网络独立：可工作在离线或低速的网络环境下。 渐进增强：适用于所有用户，无论选择什么种类的浏览器。 再参与：使用提醒注意让用户更容易的参与，即使用户没有使用他们的设备。 响应式：适合任何形式的因素：台式机，手机，平板电脑，或任何随之而来的新设备。 安全：传递机制可以防止监听，并保证内容不被篡改。 主要技术 Https Service Worker Web App Manifest Push Notification 成功案例 饿了么 新浪微博 Flipkart Instagram Twitter Offline Wikipedia PWA 资源大全: Outweb, PWA Directory PWA资料: Google Developers","tags":[{"name":"PWA","slug":"PWA","permalink":"http://yunzaifei.github.io/tags/PWA/"}]},{"title":"网站使用https，免费方便的Let's Encrypt证书","date":"2018-05-05T05:54:27.000Z","path":"2018/05/05/网站使用https，免费方便的Let-s-Encrypt证书/","text":"现在越来越多的网站升级到https了，并且Chrome和Firefox开始对HTTP网站显示不安全警告，那么如何方便快捷，最好是免费的升级https呢。没错，Let’s Encrypt证书完全能够满足你的所有需求。 Let’s Encrypt介绍Let’s Encrypt是一个免费、开放，自动化的证书颁发机构，由 ISRG（Internet Security Research Group）运作。Let’s Encrypt网址：https://letsencrypt.org/ ISRG是一个关注网络安全的公益组织，其赞助商从非商业组织到财富100强公司都有，包括Mozilla、Akamai、Cisco、Facebook，密歇根大学等等。ISRG以消除资金，技术领域的障碍，全面推进加密连接成为互联网标配为自己的使命。 Let’s Encrypt项目于2012年由 Mozilla 的两个员工发起，2014年11年对外宣布公开，2015年12月3日开启公测。 Let’s Encrypt优势Let’s Encrypt有众多互联网顶级公司的参与，保证了其自身的可信度和可持续性，加上免费这一大杀器，本应该大杀四方，哪里还有那些收费ssl证书的活路。但是，Let’s Encrypt证书的有效期只有90天，到期后需要提交更新，在初期，Let’s Encrypt 的安全证书配置起来比较麻烦，需要手动获取及部署。存在一定的门槛，没有一些技术底子可能比较难搞定。虽然有一些网友就自己做了一些脚本来优化和简化部署过程，但还是有些麻烦不是，并且个人制作的脚本存在一定的使用风险和安全隐患。 但是，现在Let’s Encrypt官方推出了Certbot工具，简单敲几行命令就能完成所有配置，并且能够自动续期，妈妈咱已不用惦记90天的问题了。 Certbot使用Certbot网址：https://certbot.eff.org/,打开网站后看到： 可以根据操作系统和使用的软件来选择相应的命令，以centos7上的nginx为例： 安装Certbot1$ sudo certbot --nginx 执行配置命令Certbot有一个Nginx插件，它在许多平台上都受支持，并且安装了证书。 1$ sudo certbot --nginx 运行此命令将为您获得证书，并让Certbot自动编辑您的Nginx配置以便为其提供服务。如果您感觉更保守，并且想手动更改Nginx配置，则可以使用certonly 子命令： 1$ sudo certbot --nginx certonly 自动更新Certbot可以配置为在证书过期之前自动续订您的证书。自从让我们将证书最后加密90天后，最好利用此功能。您可以通过运行以下命令来测试证书的自动续订： 1$ sudo certbot renew --dry-run 如果工作正常，您可以通过添加运行以下命令的cron job或systemd timer来安排自动续订： 1certbot renew 执行cron命令 1$ sudo crontab -e 一个cron的例子可能是这样的，它会在每天的中午和午夜运行： 10 0,12 * * * certbot renew certbot追加域名列出由Certbot管理的所有证书信息 1$ sudo certbot certificates 追加域名 1$ sudo certbot --expand -d existing.com -d example.com -d newdomain.com","tags":[]},{"title":"nginx缓存和Gzip压缩设置","date":"2018-01-09T14:42:58.000Z","path":"2018/01/09/nginx缓存和Gzip压缩设置/","text":"nginx 是一个高性能的 Web 服务器，为了提高响应速度，可以从设置 nginx 的 gzip 和缓存这2方面入手。开启 gzip 和缓存能大大减少带宽的消耗。 开启gzip1234567891011121314151617# 开启gzipgzip on;# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩gzip_min_length 1k;# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间gzip_comp_level 2;# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;# 是否在http header中添加Vary: Accept-Encoding，建议开启gzip_vary on;# 禁用IE 6 gzipgzip_disable &quot;MSIE [1-6]\\.&quot;; 开启缓存123456789101112location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123; access_log off; expires 30d;&#125;location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ &#123; access_log off; expires 24h;&#125;location ~* ^.+\\.(html|htm)$ &#123; expires 1h;&#125;","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yunzaifei.github.io/tags/Nginx/"}]},{"title":"通过Git Hooks实现自动部署","date":"2018-01-02T02:56:35.000Z","path":"2018/01/02/通过Git-Hooks实现自动部署/","text":"在没有接触到Git Hook之前，我一直都是在本地将代码push到远程仓库，然后再ssh到服务器上git pull，想起来都心酸。这样手工操作不仅繁琐，还非常容易出错。好在Git为我们提供了hook这种好东西，能够在特定的事件触发时执行我们写好的脚本，实现自动化部署。 为什么需要自动化部署？ 当在本地计算机完成服务器应用程序开发之后，需要把程序安装到服务器上，这样的安装过程一般称之为部署。 部署一般分为文件复制、启动服务、安装依赖等。 每次开发完成一个版本都需要部署一次。手动部署属于多次重复劳动。 身为合格的程序员，应该把一切能够自动化的劳动自动化。 通过Git Hooks实现的自动化部署，将实现敲入git push命令后，自动完成整个部署过程。 认识HooksGit Hooks提供了多种形式的Hook，以pre-commit为例，该Hook将拦截git commit操作，运行名叫pre-commit的脚本，且仅当脚本返回值为0时进行真正的commit操作。 那么自动部署所需使用的Hook名为post-receive. 该Hook将在服务器端的bare repository接收到push信息并完成push操作后，进行执行；无法中断客户端（Client）的push过程。 可能浏览完上面的介绍，还是不太明白Hook是什么。简单地说，Hook是一种特殊的脚本（代码），仅在满足特定条件时执行。Git Hooks分别有对应各种操作的Hook，可以在git repository的.git/hooks目录下看到。 1234applypatch-msg.sample pre-commit.sample prepare-commit-msg.samplecommit-msg.sample pre-push.sample update.samplepost-update.sample pre-rebase.samplepre-applypatch.sample pre-receive.sample 以上的脚本文件就是Hook了。可以看到脚本文件的后缀名都是sample，也就是说，这些都是Git自带的Hook示例，并不会真正地被执行。要想真正地被执行，只需要去掉sample后缀名即可。例如要启用pre-push的Hook（在push操作前执行脚本，脚本返回值为0时执行push操作），在hooks目录下新建一个pre-push的文件（没有后缀名）。 在脚本中，你可以写Bash、Python、JavaScript等代码，Git通过Shebang来选择执行代码的解释器。如果要写Bash，Shebang可以是这样： 1#!/usr/bin/bash 使用Windows的读者请注意，如果脚本文件含有BOM（字节序标识符），可能会导致一些问题。 当完成脚本编写后，Git Hooks便完成了。 Git Hooks与自动部署要保证不是git服务端和要部署的网站目录在同一台服务器，并且最好都属于git用户，这样不需要考虑操作权限问题了。 git hooks部署 裸仓库接收push之后怎么自动去执行pull操作，git仓库中有个.git文件夹，里面有个hooks文件夹，git 钩子就藏在这。里面有很多文件，其中有个post-receive.sample文件（没有的话也没有关系，新建一个post-receive文件，注意不带sample后缀，带上这个后缀默认是不触发执行的），我们要做的脚本代码就在这里个文件里面完成。 下面的示例是使用nodejs生成的静态网站，先执行git pull获取最新代码，然后检查node_modules文件夹是否存在，如果不存在，执行npm install命令。然后检查package.json文件，如果变动，执行npm install命令，最后执行npm run build命令生成静态网站文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bashWORKTREE=/var/www/xxxwebCONFIG=package.jsonwhile read oldrev newrev ref # post-receive 将读取这三个变量do if [[ $ref =~ .*/master$ ]]; # 仅允许master分支进行部署 then echo &quot;Pull to worktree...&quot; #echo &quot;$oldrev $newrev&quot; cd $WORKTREE unset GIT_DIR git pull &amp;&gt; /dev/null if [ ! -d &quot;/node_modules&quot; ] # 如果node_modules文件夹不存在 then echo &quot;install packages...&quot; npm install fi git diff --quiet $oldrev $newrev -- $CONFIG if [ &quot;$?&quot; -eq &quot;1&quot; ] # 当package.json被修改时，安装依赖 then echo &quot;package.json changed&quot; export LC_ALL=C # 去除所有本地化的设置 echo &quot;install packages...&quot; npm install else echo &quot;package.json does not changed&quot; fi #如果是需要PM2启动服务 pm2 show api &amp;&gt; /dev/null #查看PM2是否启动 if [ &quot;$?&quot; -eq &quot;1&quot; ] then pm2 start app.js -n &#x27;api&#x27; else pm2 restart api fi #如果是生成网页 npm run build # 生成dist echo &quot;build complete&quot; else echo &quot;This is not master branch, and it will not be deployed&quot; fidone 对了，编辑完post-receive文件，要赋予其执行权限，chmod +x post-receive，并且改变文件所有者chown git:git post-receive。 权限处理在上述代码示例中，我部署了的网站工作目录是/var/www/xxxweb，所属用户是git，如果不是，执行1chown -R git:git xxxweb 因为所属用户是git，钩子脚本的所有者也是git，所以权限是没有问题的（如果不是同属于git用户，命令需要sudo，同时需要配置权限，比较麻烦，不建议）。可能有些时候需要在git用户下执行ssh -T git@127.0.0.1添加known_hosts。","tags":[{"name":"Git","slug":"Git","permalink":"http://yunzaifei.github.io/tags/Git/"}]},{"title":"Web API文档生成工具apidoc","date":"2017-12-26T01:24:52.000Z","path":"2017/12/26/Web-API文档生成工具apidoc/","text":"在项目开发过程中，总会牵扯到接口文档的设计与编写，如果使用office工具，写一个文档，总也是不够漂亮和直观。好在git上的开源大神提供了生成文档的工具，so来介绍一下apidoc！ apidoc可以根据代码注释生成web api文档，支持大部分主流语言java javascript php coffeescript erlang perl python ruby go…，相对而言，web接口的注释维护起来更加方便，不需要额外再维护一份文档。 apidoc从注释生成静态html网页文档，不仅支持项目版本号，还支持api版本号。 安装主页: http://apidocjs.comgithub: https://github.com/apidoc/apidoc可以使用npm install apidoc -g进行安装。如果不想使用全局命令，可以使用下面的构建工具： flask-apidoc pip install flask-apidoc grunt-apidoc npm install grunt-apidoc gapidoc (gulp) npm install gapidoc gulp-apidoc npm install gulp-apidoc 应用在命令行窗口执行apidoc -h命令，可以查看帮助。下面讲讲常用的方法 12345678// 典型用法apidoc -i api/ -o doc/api [-c ./] -f &quot;.*\\.js$&quot;-i 表示输入，后面是文件夹路径-o 表示输出，后面是文件夹路径默认会带上-c，在当前路径下寻找配置文件(apidoc.json)，如果找不到则会在package.json中寻找 &quot;apidoc&quot;: &#123; &#125;-f 为文件过滤，后面是正则表达式，示例为只选着js文件与-f类似，还有一个 -e 的选项，表示要排除的文件/文件夹，也是使用正则表达式 配置文件（apidoc.json）apidoc.json示例： 1234567&#123; &quot;name&quot;: &quot;example&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;apiDoc basic example&quot;, &quot;title&quot;: &quot;Custom apiDoc browser title&quot;, &quot;url&quot; : &quot;https://api.github.com/v1&quot;&#125; 如果放入package.json中，相同的字段可以直接使用package.json的定义，额外的字段放入apidoc下 123456789&#123; &quot;name&quot;: &quot;example&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;description&quot;: &quot;apiDoc basic example&quot;, &quot;apidoc&quot;: &#123; &quot;title&quot;: &quot;Custom apiDoc browser title&quot;, &quot;url&quot; : &quot;https://api.github.com/v1&quot; &#125;&#125; 注释写法常用关键字 1234567891011121314151617181920212223242526272829303132333435363738@api &#123;method&#125; path [title] 只有使用@api标注的注释块才会在解析之后生成文档，title会被解析为导航菜单(@apiGroup)下的小菜单 method可以有空格，如&#123;POST GET&#125;@apiGroup name 分组名称，被解析为导航栏菜单@apiName name 接口名称，在同一个@apiGroup下，名称相同的@api通过@apiVersion区分，否者后面@api会覆盖前面定义的@api@apiDescription text 接口描述，支持html语法@apiVersion verison 接口版本，major.minor.patch的形式 @apiIgnore [hint] apidoc会忽略使用@apiIgnore标注的接口，hint为描述@apiSampleRequest url 接口测试地址以供测试，发送请求时，@api method必须为POST/GET等其中一种@apiDefine name [title] [description] 定义一个注释块(不包含@api)，配合@apiUse使用可以引入注释块 在@apiDefine内部不可以使用@apiUse@apiUse name 引入一个@apiDefine的注释块@apiParam [(group)] [&#123;type&#125;] [field=defaultValue] [description]@apiHeader [(group)] [&#123;type&#125;] [field=defaultValue] [description]@apiError [(group)] [&#123;type&#125;] field [description]@apiSuccess [(group)] [&#123;type&#125;] field [description] 用法基本类似，分别描述请求参数、头部，响应错误和成功 group表示参数的分组，type表示类型(不能有空格)，入参可以定义默认值(不能有空格)@apiParamExample [&#123;type&#125;] [title] example@apiHeaderExample [&#123;type&#125;] [title] example@apiErrorExample [&#123;type&#125;] [title] example@apiSuccessExample [&#123;type&#125;] [title] example 用法完全一致，但是type表示的是example的语言类型 example书写成什么样就会解析成什么样，所以最好是书写的时候注意格式化，(许多编辑器都有列模式，可以使用列模式快速对代码添加*号) @apiPermission name name必须独一无二，描述@api的访问权限，如admin/anyone 文档生成后的结果是这样的：http://apidocjs.com/example/","tags":[{"name":"apidoc","slug":"apidoc","permalink":"http://yunzaifei.github.io/tags/apidoc/"}]},{"title":"koa2开发的api服务及jwt应用","date":"2017-09-22T00:56:56.000Z","path":"2017/09/22/koa2开发的api服务及jwt应用/","text":"koa2开发的api服务示例，使用用jwt验证。 github代码：https://github.com/yunzaifei/koa2-jwt-demo 安装及部署 执行命令npm install 执行命令npm start启动服务 可以通过postman等工具对服务进行测试，或者通过npm run test命令使用网页页查看 涉及知识点 koa2框架 jwt原理及应用 mongoose应用 async/await的简单使用 知识点讲解koa2框架koa就是一种简单好用的Web框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合Unix哲学。 koa官网 http://koajs.com/ koa中文文档 https://github.com/guo-yu/koa-guide koa2进阶学习笔记 https://chenshenhai.github.io/koa2-note/ 本示例中涉及的中间件 中间件 功能说明 链接 备注 bcrypt 加密 用于用户密码存入数据库时 jsonwebtoken jwt实现 kcors koa跨域 koa koa框架 koa-bodyparser 数据解析到ctx.request.body中 详细 koa-json response转换位json格式 koa-jwt jwt自动校验 使用后不用在每个路由下手写校验方法 koa-logger 日志 koa-router 路由 详细 mongoose 操作mongodb数据库 文档 代码结构说明本示例代码实现api服务，因为没有页面展示功能，所以没有使用koa-static加载静态资源和创建views视图结构。 启动文件是app.js。 route文件夹是路由服务。 config.js文件记录所有配置信息方便统一管理。 jwt原理及应用jwt原理JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。注意，在JWT中，不应该在载荷里面加入任何敏感的数据。查看jwt信息：https://jwt.io/ jwt原理 基于Token的WEB后台认证机制 jwt应用对于jwt的应用，本示例中主要用到jsonwebtoken和koa-jwt两个中间件。koa-jwt是对jsonwebtoken功能的封装，如果想更灵活的实现并且不怕麻烦，可以只使用jsonwebtoken中间件。 jsonwebtoken用法 123456789101112//jsonwebtoken在服务端生成token返回给客户端const jwt = require(&#x27;jsonwebtoken&#x27;)const token = jwt.sign(&#123; id: user._id, secret: user.app_secret&#125;, config.jwt_secret, &#123;expiresIn: 3600&#125;) ctx.body = &#123; code: 200, message: &#x27;登录成功!&#x27;, token: token&#125; koa-jwt用法 123456789101112//koa-jwt在服务端校验从客户端提交的token值const app = new Koa()const jwt = require(&#x27;koa-jwt&#x27;)app.use(jwt(&#123;secret: config.jwt_secret&#125;).unless(&#123;path:[/^\\/api\\/login/, /^\\/api\\/register/]&#125;)) //usless排除进行jwt校验的路由//在路由中处理const router = require(&#x27;koa-router&#x27;)()router.post(&#x27;/xxx&#x27;, async ctx =&gt; &#123; const token = ctx.state.user console.log(&#x27;user_id:&#x27;, token.id) console.log(&#x27;user.app_secret:&#x27;, token.secret)&#125; mongoose应用mongoose文档：http://mongoosejs.com/docs/guide.html mongoose中文文档：https://mongoose.shujuwajue.com/ async/await的简单使用async 函数 深入理解ES7的async/await Callback、Promise、Generator、async/await对比","tags":[{"name":"koa","slug":"koa","permalink":"http://yunzaifei.github.io/tags/koa/"},{"name":"jwt","slug":"jwt","permalink":"http://yunzaifei.github.io/tags/jwt/"}]},{"title":"搭建自己的Git服务器","date":"2017-01-13T05:43:47.000Z","path":"2017/01/13/搭建自己的Git服务器/","text":"Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。Git与常用的版本控制工具CVS, SVN等不同，它采用了分布式版本库的方式，不必服务器端软件支持。Github是一个基于git的代码托管平台，Github公开的项目是免费的，但是如果你不想让其他人看到你的项目就需要收费。这时我们就需要自己搭建一台Git服务器作为私有仓库使用。接下来我们将以Centos 7为例搭建Git服务器,其中Centos 7作为服务端，windows系统作为客户端。 sever 安装git1yum install git 新建一个linux用户，起名为git（当然也可以叫其他名字）1useradd git 在git用户目录中新建目录.ssh12$ mkdir .ssh$ chmod 700 .ssh 在/home/git/.ssh/目录中新建authorized_keys文件，并将客户端提供的公钥(id_rsa.pub)黏贴到该文件中12$ touch .ssh/authorized_keys$ chmod 600 .ssh/authorized_keys 创建一个git裸仓库，假如当前项目目录为/home/git/xxx.git1git init --bare xxx.git 将项目目录和git用户目录下的.ssh目录的所有者和所属组都设置成git12chown -R git.git xxx.git chown -R git.git /home/git/.ssh/ 为了安全考虑，禁用git用户的shell登录123vi /etc/passwd注释 ##git:x:000:000::/home/git:/bin/bash (git:x:000:000中数字不要改动，文件中是多少就是多少)改为 git:x:000:000:git version control:/home/git:/usr/bin/git-shell git服务器打开RSA认证12345vi /etc/ssh/sshd_config下面3个打开 1.RSAAuthentication yes 2.PubkeyAuthentication yes 3.AuthorizedKeysFile .ssh/authorized_keys client 生成公钥,并复制到服务端authorized_keys文件12ssh-keygen -t rsa -C &quot;标识名&quot;ssh-add -L 在C:/Users/用户名/.ssh下新建config文件，config文件内容123456#注释名称Host xxxx(自定义host名称)HostName xxx.xxx.xxx.xxx(服务端ip地址)user git(服务端作为git仓库的用户名)Port 22(服务端ssh端口号)IdentityFile ~/.ssh/id_rsa(默认值为id_rsa，如果个性化名称，请填写个性化的名称) 新建一个文件夹，克隆仓库1git clone git@xxxx(config文件中自定义host名称)：/home/git/xxx.git 常用个git命令 新建代码库12345678#在当前目录新建一个Git代码库$ git init # 新建一个目录，将其初始化为Git代码库$ git init [project-name] # 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list # 编辑Git配置文件$ git config -e [--global] # 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch] # 新建一个分支，指向指定commit$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区$ git checkout [branch-name] # 切换到上一个分支$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit] # 删除本地tag$ git tag -d [tag] # 删除远程tag$ git push origin :refs/tags/[tagName] # 查看tag信息$ git show [tag] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags # 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log # 显示commit历史，以及每次commit发生变更的文件$ git log --stat # 搜索提交历史，根据关键词$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] # 显示指定文件相关的每一次diff$ git log -p [file] # 显示过去5次提交$ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序$ git shortlog -sn # 显示指定文件是什么人在什么时间修改过$ git blame [file] # 显示暂存区和工作区的差异$ git diff # 显示暂存区和上一个commit的差异$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异$ git diff HEAD # 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; # 显示某次提交的元数据和内容变化$ git show [commit] # 显示某次提交发生变化的文件$ git show --name-only [commit] # 显示某次提交时，某个文件的内容$ git show [commit]:[filename] # 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote] # 显示所有远程仓库$ git remote -v # 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force # 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 其他1234# 生成一个可供发布的压缩包$ git archive# 忽略更新（适用于配置信息等）$ git update-index --assume-unchanged &lt;file-path&gt;","tags":[{"name":"Git","slug":"Git","permalink":"http://yunzaifei.github.io/tags/Git/"}]},{"title":"nginx简单用法和介绍","date":"2016-08-19T09:31:46.000Z","path":"2016/08/19/nginx简单用法和介绍/","text":"Nginx（发音同engine x） 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由Igor Sysoev为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名，其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 Nginx官网：http://nginx.org/&nbsp;&nbsp;https://www.nginx.com/ 安装 编译安装下载对应的安装包进行编译安装12./configure --user=www --group=www --prefix=/usr/local/nginx/ --with-http_stub_status_module --with-openssl=/usr/local/opensslmake &amp;&amp; make install yum安装（以centos7为例）官方示例：https://www.nginx.com/resources/wiki/start/topics/tutorials/install/123456789101112131415161718#新建repo文件vi /etc/yum.repos.d/nginx.repo #复制以下内容[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 #保存退出后，生成源数据缓存yum makecache #之后就可以yum命令安装yum install nginx #yum命令更新yum update nginx Nginx反向代理 proxy_pass语法：proxy_pass URL;配置块：location、if此配置项将当前请求反向代理到URL参数指定的服务器上，URL可以是主机名或IP地址加端口的形式，例如： 1proxy_pass http://localhost:8000/uri/; 也可以是UNIX句柄： 1proxy_pass http://unix:/path/to/backend.socket:/uri/; 还可以如上节负载均衡中所示，直接使用upstream块，例如： 123456789upstream backend &#123; …&#125; server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 用户可以把HTTP转换成更安全的HTTPS，例如： 1proxy_pass https://192.168.0.1; 默认情况下反向代理是不会转发请求中的Host头部的。如果需要转发，那么必须加上配置： 1proxy_set_header Host $host; proxy_method语法：proxy_method method;配置块：http、server、location此配置项表示转发时的协议方法名。例如设置为 1proxy_method POST; 那么客户端发来的GET请求在转发时方法名也会改为POST。 proxy_hide_header语法：proxy_hide_header the_header;配置块：http、server、locationNginx会将上游服务器的响应转发给客户端，但默认不会转发以下HTTP头部字段：Date、Server、X-Pad和X-Accel-*。使用proxy_hide_header后可以任意地指定哪些HTTP头部字段不能被转发。例如： 12proxy_hide_header Cache-Control;proxy_hide_header MicrosoftOfficeWebServer; proxy_pass_header语法：proxy_pass_header the_header;配置块：http、server、location与proxy_hide_header功能相反，proxy_pass_header会将原来禁止转发的header设置为允许转发。例如： 1proxy_pass_header X-Accel-Redirect; proxy_pass_request_body语法：proxy_pass_request_body on | off;默认：proxy_pass_request_body on;配置块：http、server、location作用为确定是否向上游服务器发送HTTP包体部分。 proxy_pass_request_headers语法：proxy_pass_request_headers on | off;默认：proxy_pass_request_headers on;配置块：http、server、location作用为确定是否转发HTTP头部。 proxy_redirect语法：proxy_redirect [ default|off|redirect replacement ];默认：proxy_redirect default;配置块：http、server、location当上游服务器返回的响应是重定向或刷新请求（如HTTP响应码是301或者302）时，proxy_redirect可以重设HTTP头部的location或refresh字段。例如，如果上游服务器发出的响应是302重定向请求，location字段的URL是：http://localhost:8000/two/some/uri/,那么在下面的配置情况下，实际转发给客户端的location是http://frontend/one/some/uri/。 1proxy_redirect http://localhost:8000/two/ http://frontend/one/; 这里还可以使用ngx-http-core-module提供的变量来设置新的location字段。例如 1proxy_redirect http://localhost:8000/ http://$host:$server_port/; 也可以省略replacement参数中的主机名部分，这时会用虚拟主机名称来填充。例如： 1proxy_redirect http://localhost:8000/two/ /one/; 使用off参数时，将使location或者refresh字段维持不变。例如： 1proxy_redirect off; 使用默认的default参数时，会按照proxy_pass配置项和所属的location配置项重组发往客户端的location头部。例如，下面两种配置效果是一样的： 123456789location /one/ &#123; proxy_pass http://upstream:port/two/; proxy_redirect default; &#125; location /one/ &#123; proxy_pass http://upstream:port/two/; proxy_redirect http://upstream:port/two/ /one/; &#125; proxy_next_upstream语法：proxy_next_upstream [error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_404 | off ];默认：proxy_next_upstream error timeout;配置块：http、server、location此配置项表示当向一台上游服务器转发请求出现错误时，继续换一台上游服务器处理这个请求。前面已经说过，上游服务器一旦开始发送应答，Nginx反向代理服务器会立刻把应答包转发给客户端。因此，一旦Nginx开始向客户端发送响应包，之后的过程中若出现错误也是不允许换下一台上游服务器继续处理的。这很好理解，这样才可以更好地保证客户端只收到来自一个上游服务器的应答。proxy_next_upstream的参数用来说明在哪些情况下会继续选择下一台上游服务器转发请求。error：当向上游服务器发起连接、发送请求、读取响应时出错。timeout：发送请求或读取响应时发生超时。invalid_header：上游服务器发送的响应是不合法的。http_500：上游服务器返回的HTTP响应码是500。http_502：上游服务器返回的HTTP响应码是502。http_503：上游服务器返回的HTTP响应码是503。http_504：上游服务器返回的HTTP响应码是504。http_404：上游服务器返回的HTTP响应码是404。off：关闭proxy_next_upstream功能—出错就选择另一台上游服务器再次转发。 简单示例（以centos7为例） 反向代理网站123456789101112#新增配置文件vi /etc/nginx/conf.d/fxdl.conf#复制以下内容server&#123; listen 80; server_name gl.yunzaifei.com; location / &#123; proxy_pass https://www.google.com; &#125;&#125;#保存退出后重启nginxnginx -s reload 反向代理北地端口12345678910111213141516171819#新增配置文件vi /etc/nginx/conf.d/fxdl.conf#复制以下内容server &#123; listen 80; server_name api.xxx.com; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8000/; proxy_redirect off; &#125;&#125;#保存退出后重启nginxnginx -s reload Nginx的反向代理模块还提供了很多种配置，如设置连接的超时时间、临时文件如何存储，以及最重要的如何缓存上游服务器响应等功能。这些配置可以通过阅读ngx_http_proxy_module模块的说明了解，只有深入地理解，才能实现一个高性能的反向代理服务器。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yunzaifei.github.io/tags/Nginx/"}]},{"title":"Redis在windwos上安装使用","date":"2016-05-04T02:28:39.000Z","path":"2016/05/04/Redis在windwos上安装使用/","text":"Redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。Redis对于Linux是官方支持的,安装和使用没有什么好说的,普通使用按照官方指导，5分钟以内就能搞定。详情请参考Redis官网:http://redis.io/。但有时候又想在windows下折腾下Redis,Redis官方是不支持windows的，只是Microsoft Open Tech group在GitHub上开发了一个Win64的版本,项目地址是：https://github.com/MSOpenTech/redis。 安装Redis在 Release 页面中，可以找到msi安装文件以及 .zip 文件(而且有3.0的版本，请下拉查找)。下载msi安装文件，选择安装目录，不断下一步即可安装成功。 启动Redis下载msi文件后，可以打开服务列表，看看是否多了一个“Redis”的服务，如果有并且该服务已经启动，就表示已经启动Redis了。如果没有，请以管理员身份打开cmd窗口，进入Redis安装目录，敲入如下命令： 1redis-server redis.windows.conf 测试使用双击打开 redis-cli.exe , 如果不报错,则连接上了本地服务器,然后测试，比如 set命令，get命令 12345127.0.0.1:6379&gt; set name yunzaifei OK 127.0.0.1:6379&gt; get name &quot;yunzaifei&quot; 127.0.0.1:6379&gt; 如果需要帮助,可以在 cli窗口中输入 help查看,例如: 123456127.0.0.1:6379&gt; helpredis-cli 2.8.2400Type: &quot;help @&lt;group&gt;&quot; to get a list of commands in &lt;group&gt; &quot;help &lt;command&gt;&quot; for help on &lt;command&gt; &quot;help &lt;tab&gt;&quot; to get a list of possible help topics &quot;quit&quot; to exit","tags":[{"name":"redis","slug":"redis","permalink":"http://yunzaifei.github.io/tags/redis/"},{"name":"widnows","slug":"widnows","permalink":"http://yunzaifei.github.io/tags/widnows/"}]},{"title":"mongodb3在windows上安装和启动","date":"2016-05-03T01:22:55.000Z","path":"2016/05/03/mongodb3在windows上安装和启动/","text":"Windows下安装MongoDB，虽然网上有很多攻略，但是还是有很多坑，为了以后少犯错误，特此记录。 官方下载地址：https://www.mongodb.org/downloads#production ###安装MongoDB 执行安装直接点击安装包一路next下去，你懂的。不过最好把安装路径修改到非系统盘。 配置比如我将MongoDB安装在D:\\MongoDB\\Server\\3.2这个目录下，那么先要在目录D:\\MongoDB(可以是任意位置，不过为了以后好管理，最好放到一块)下手动新建两个个文件夹：data、logs，再新建一个配置文件mongo.conf(名称可以任意取)。配置文件里面的内容是： 12dbpath=D:\\MongoDB\\datalogpath=D:\\MongoDB\\log\\mongo.log 启动MongoDB用管理员权限打开CMD，里面依次执行下面几行命令： 12cd D:\\MongoDB\\Server\\3.2\\binmongod --config D:\\MongoDB\\mongo.conf --serviceName &quot;MongoDB&quot; --install 这时去服务列表，可以看到多了一项MongoDB的服务，启动该服务，以后就开机自动启动MongoDB服务了。 备注：如果想要删除该服务，用管理员权限打开CMD，执行命令： 1sc delete MongoDB 验证MongoDB服务验证服务是否正常启动，可以在cmd命令中敲入“mongo”命令，正常启动的话会看到提示信息，按ctrl+c退出当前命令。","tags":[{"name":"widnows","slug":"widnows","permalink":"http://yunzaifei.github.io/tags/widnows/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yunzaifei.github.io/tags/mongodb/"}]},{"title":"nodejs安装","date":"2016-01-19T08:02:25.000Z","path":"2016/01/19/nodejs安装/","text":"Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。nodjs官网：https://nodejs.org windows下安装windows下的安装很简单，直接去官网下载安装包，下载完成后双击之后下一步直到完成。然后打开cmd命令行窗口敲入命令“node -v”，如果按照成功，就会显示对应的版本号。 不过windows下虽然安装的时候能够选择nodejs的安装路径（比如为了减少C盘空间，安装在D盘），但是npm的默认路径是在C盘AppData下，如果希望npm全局安装路径，可以进行如下操作： 假设nodejs的安装路径是D:\\Program Files\\nodejs，在此路径下建立node_global及node_cache两个文件夹。在路D:\\Program Files\\nodejs\\node_modules\\npm下找一个名字为npmrc的文件，用记事本打开，修改为12prefix = D:\\Program Files\\nodejs\\node_globalcache = D:\\Program Files\\nodejs\\node_cache 修改环境变量，“我的电脑”右键“属性”-“高级系统设置”-“高级”-“环境变量”，在系统变量下新建NODE_PATH，输入是D:\\Program Files\\nodejs\\node_global\\node_modules。上面的用户变量都要跟着改变一下（用户变量“PATH”中的C:\\Users\\&#123;用户名&#125;\\AppData\\Roaming修改为D:\\Program Files\\nodejs\\node_global\\），保存修改即可。 linux下安装（以centos为例）linux的安装可以分为yum命令安装和源码编译安装两种 源码编译安装去官网下载Source code文件 123456789# tar xvf node-v4.2.4.tar.gz# cd node-v4.2.4# ./configure# make# make install# cp /usr/local/bin/node /usr/sbin///查看当前安装的Node的版本# node -v 这方式的缺点就是版本编译的时间较长，甚至中间会出现错误。 yum命令安装在centos中执行如下命令 1234//可以不添加“-y”参数# yum install -y nodejs//查看nodejs版本# node -v 这样执行完之后，你会发现nodejs的版本是lts版本（最好安装了epel源），不是最新的，我想要最新的版本有没有啊，或者我想切换着不同版本使用！不怕，还有一个东西叫npm呢，NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。最新的nodejs版本都会集成安装npm，无须单独安装。不过，通过yum命令安装的nodejs竟然没有集成npm（centos7上如此，其他linux版本情况请自行查看），不怕，yum命令能安装nodejs，也能安装npm。 123456789101112131415161718//安装npm# yum install -y npm//查看npm版本# npm -v//更新npm到最新版# npm install -g npm//安装传说中的n模块# npm install -g n//nodejs版本分为最新稳定版（stable）和长效版（lts），推荐安装长效版（lts）# n lts//安装最新稳定版（stable）# n stable//安装特定版本，比如v0.10.26# n v0.10.26//查看nodejs版本# node -v//查看npm版本# npm -v nodejs官方curl命令 官方网址：https://nodejs.org/en/download/package-manager/在centos中执行如下命令 1234# 安装Node.js v8 LTS:curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -# 安装Node.js 9:curl --silent --location https://rpm.nodesource.com/setup_9.x | sudo bash - 此时如果执行“cd /etc/yum.repos.d &amp;&amp; ls”命令，可以看到一个“nodesource-el7.repo”的文件，之后就可以使用yum命令安装 1sudo yum -y install nodejs 结语总得来说，还是yum命令安装最省心省力, 如果没有切换多版本的需求，可以使用官方curl命令的方式。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yunzaifei.github.io/tags/nodejs/"}]},{"title":"mongodb3在Centos7上安装和启动","date":"2016-01-11T01:41:49.000Z","path":"2016/01/11/mongodb3在Centos7上安装和启动/","text":"MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 官方教程：https://docs.mongodb.org/manual/tutorial/install-mongodb-on-red-hat 安装MongoDB 配置yum安装源创建/etc/yum.repos.d/mongodb-org-3.2.repo文件1$ vi /etc/yum.repos.d/mongodb-org-3.2.repo 文件里面写入如下内容：12345[mongodb-org-3.2]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/gpgcheck=0enabled=1 安装MongoDB的包和相关的工具当您安装的软件包，您可以选择是否安装当前版本或前一个。此步骤提供的命令为两者。要安装的MongoDB的最新稳定版本，发出以下命令：1$ sudo yum install -y mongodb-org 要安装MongoDB中的一个特定版本，分别指定每个组件包并追加版本号的包名，如下面的例子：1$ sudo yum install -y mongodb-org-3.2.0 mongodb-org-server-3.2.0 mongodb-org-shell-3.2.0 mongodb-org-mongos-3.2.0 mongodb-org-tools-3.2.0 运行MongoDB 配置SELinux查看SELinux状态： 1$ sestatus -v 修改配置文件/etc/selinux/config 1SELINUX=disabled 启动服务 123456#启动服务$ systemctl start mongod#停止服务$ systemctl stop mongod#重启服务$ systemctl restart mongod 运行 12345$ mongo#进入admin库&gt; use admin#创建超级管理员&gt; db.createUser(&#123;user:&#x27;用户名&#x27;,pwd:&#x27;密码&#x27;,roles:[&#x27;userAdminAnyDatabase&#x27;]&#125;) 启用安全验证 1234$ vi /etc/mongod.conf#增加如下内容security: authorization: enabled 卸载MongoDB 停止服务1$ systemctl stop mongod 卸载安装1$ sudo yum erase $(rpm -qa | grep mongodb-org) 删除数据文件12$ sudo rm -r /var/log/mongodb$ sudo rm -r /var/lib/mongo","tags":[{"name":"linux","slug":"linux","permalink":"http://yunzaifei.github.io/tags/linux/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yunzaifei.github.io/tags/mongodb/"}]},{"title":"linux安全设置","date":"2016-01-08T02:21:25.000Z","path":"2016/01/08/linux安全设置/","text":"我们在学会了VPS的安装和建站之后，肯定需要附带学习VPS的安全设置。因为VPS和主机不同，主机商可能会给我们备份，而且主机的安全性都有主机商承担。但是，如果现在我们在使用VPS，那VPS的安全性主机商是不承担的，既然我们选择使用VPS，就一定要做好安全维护。接下来就以Centos7为例进行讲解： 修改SSH端口不管我们的网站是不是出名，很多黑客选手或者同行都是用软件直接扫描网站VPS/主机端口的，一般的大家都知道VPS端口为22，如果我们修改了端口至少先找不到端口，很多时候由于我们的端口是默认，即便主机安全也会留下大量的日志文件。这些文件就是被暴利破解的错误记录。 修改SSH端口的方法：登陆SSH，然后通过vi /etc/ssh/sshd_config 命令打开文件，修改其中的port后面的数字。最后一步就是重启ssh，需要注意的是不同版本的linux是不同的命令。 Centos7: systemctl restart sshd 这个时候千万不要急着关闭当前ssh连接 因为你的VPS可能启动了防火墙，而你新设置的端口可能会被防火墙拦截 检查防火墙是否开发，以Centos7为例： 12345$ firewall-cmd --state#如果没有开启，结果是not running#如果开启，结果是running 永久开启端口： 123456#查看开启的端口号$ firewall-cmd --zone=public --list-ports#添加端口号$ firewall-cmd --permanent --zone=public --add-port=[端口号]/tcp#重启firewall$ systemctl restart firewalld 保险起见，可以再打开一个ssh连接测试，成功后就可以关闭ssh连接了。 禁用root账号一般的我们使用账户登陆都直接用ROOT登陆。如果我们把ROOT账户禁用，添加一个自己知道的账户，那VPS的安全入口基本完成。至少除了猜测密码还需要猜测用户名。 第一步 新建用户1234#为登录名sam产生一个主目录/usr/sam$ useradd –d /usr/sam -m sam#为用户名设置密码$ passwd sam 然后需要输入两次密码。 第二步 设置禁止ROOT用户就是我们需要设置禁止ROOT用户，这需要编译文件的。我们可以通过VI命令操作 1$ vi /etc/ssh/sshd_config 和之前的设置端口一样，编译sshd_config文件，把PermitRootLogin中的YES改成NO保存退出，重启SSH： Centos7: systemctl restart sshd 第三步，提权用我们新添加的用户名登陆，然后su root进行提权，让新用户有ROOT用户有的最高权限。 保险起见，还是应该打开一个新的ssh连接测试，成功后再关闭原来的ssh连接。 SSH禁止密码登录如果担心密码被暴力破解，可以添加SSH登录，并且禁止密码登录。这样每次登录不要输入密码，并且更安全，唯一不足的地方就是换个电脑就要重新折腾一次将本地公钥内容追加到远程主机的授权文件（authorized_keys）中。 本地生成密钥对12# 在本机命令行控制台输入：$ ssh-keygen 此时会在系统用户的.ssh目录下生成一对密钥文件：私钥文件id_rsa和公钥文件id_rsa_pub。 将本地公钥内容追加到远程主机的授权文件（authorized_keys）中 本地查看id_rsa_pub文件内容，复制得到的公钥字符串，在远程服务器上编辑authorized_keys文件 1$ vi ~/.ssh/authorized_keys 将刚刚得到的本地公钥字符串添加到该文件的末尾（如果是新建的文件就直接添加），编辑保存完成后，修改该文件的权限 1$chmod 600 .ssh/authorized_keys 修改ssh配置 编辑远程服务器上的sshd_config文件： 1$vi /etc/ssh/sshd_config 找到如下选项并修改(通常情况下，前两项默认为no，地三项如果与此处不符，以此处为准)： 12345#启用密钥验证RSAAuthentication yesPubkeyAuthentication yes#指定公钥数据库文件AuthorsizedKeysFile.ssh/authorized_keys 同时禁止密码登录 12#将PasswordAuthentication yes 改为PasswordAuthentication no 编辑保存完成后，重启ssh服务使得新配置生效： 1$ systemctl restart sshd.service 配置epel源具体请参见：http://fedoraproject.org/wiki/EPEL通过wget命令下载RPM文件，然后安装。 123RHEL/CentOS 7$ wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm$ rpm -ivh epel-release-latest-7.noarch.rpm 如何检查epel是否安装成功？使用一下命令： 1# yum repolist","tags":[{"name":"linux","slug":"linux","permalink":"http://yunzaifei.github.io/tags/linux/"}]},{"title":"使用GitHub和Hexo搭建免费静态播客","date":"2016-01-06T01:28:09.000Z","path":"2016/01/06/使用GitHub和Hexo搭建免费静态播客/","text":"习惯自己写Blog的朋友一定不会陌生Wordpress，或许也曾在新浪博客和QQ空间留过脚印，但静心认真思考一下，似乎我们又总是向往更加简单自由的写作方式。GitHub给我们提供了一个无限的空间，我们需要珍惜使用，而Hexo的出现从某种意义上来说代替了Jekyll，让我们可以更专注于写作本身。本文主要介绍自己的实践心得并不断完善内容，衍生知识和原理推荐大家认真阅读官网的手册，其它推荐参考内容链接在文中也会标注出来。 扩展阅读Hexo Docs - http://hexo.io/docs/ 准备工作 注意 本文主要针对平台windows和Hexo 3.x 了解Hexo A fast, simple &amp; powerful blog framework Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。hexo.io 安装GITGitHub Windows简单可依赖，安装完成后依据提示操作即可，So Easy 安装Node.JSNode.JS注意 安装完成后添加Path环境变量，使npm命令生效。新版已经会自动配置Path 安装Hexo配置好GitHub家目录后，双击桌面上的Git Shell，输入npm命令即可安装 12npm install hexo-cli -gnpm install hexo --save Hexo初始化配置创建Hexo文件夹安装完成后，根据自己喜好建立目录（如E:\\GitHub\\hexo），进入Git Shell切换到该路径下E:\\GitHub\\hexo执行以下指令 1234567891011121314151617hexo init#安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install#新建完成后，指定文件夹的目录如下.├── _config.yml├── package.json├── scaffolds├── scripts├── source| ├── _drafts| └── _posts└── themes 安装Hexo插件12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 本地查看效果继续执行以下命令，成功后可登录localhost:4000查看效果 1hexo server Hexo简写命令1234hexo n #生成文章，或者source\\_posts手动编辑hexo s #本地发布预览效果hexo g #生成public静态文件最后我选择手动同步更新至GitHub 部署静态网页到GitHub注册设置GitHub 登录GitHub，注册自定义用户名如yunzaifei 在主页右下角创建New repository，name必须和用户名一致如http://yunzaifei.github.io 首次创建耐心等待10分钟左右审核，之后即可访问静态主页如http://yunzaifei.github.io同步内容至GitHub 下载GitHub Windows 设置Local path如E:\\GitHub&lt;/font&gt; 运行Git Shell切换到如E:\\GitHub\\hexo路径下 执行hexo g命令生成public文件夹 把生成的内容全部拷贝到Local path或其子目录 运行GitHub确认修改信息后执行右上角的Sync同步 最后访问主页观察效果如http://yunzaifei.github.io Hexo主题选择自己喜欢的主题Hexo Themes - http://hexo.io/themes/Themes Wiki - https://github.com/hexojs/hexo/wiki/Themes 常见问题1.修改配置文件时注意YAML语法，参数冒号:后一定要留空格2.中文乱码请修改文件编码格式为UTF-8 如何迁移至Hexohttp://hexo.io/zh-cn/docs/migration.html","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yunzaifei.github.io/tags/Hexo/"}]}]